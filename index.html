<!DOCTYPE html>
<html>
<head>
    <title>On The Inside</title>

    <link rel="icon" type="image/x-icon" href="https://cdn-icons-png.flaticon.com/512/2418/2418779.png">
<!--    <link rel="stylesheet" href="assets/css/style.css">-->

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.7.0/d3.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-zoom.v3.min.js"></script>

    <style>
        @font-face {
            font-family: 'F1_Regular';
            src: url('assets/fonts/Formula1-Regular_web_0.ttf') format('truetype');
        }

        @font-face {
            font-family: 'F1_Bold';
            src: url('assets/fonts/Formula1-Bold_web_0.ttf') format('truetype');
        }

        @font-face {
            font-family: 'F1_Wide';
            src: url('assets/fonts/Formula1-Wide_web_0.ttf') format('truetype');
        }

        body {
            background-color: #f5f5f5;
            font-family: 'F1_Regular', Arial, sans-serif;
        }

        #Title {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #header {
            background-color: #333;
            font-family: 'F1_Wide', Arial, sans-serif;
            color: red;
            padding: 20px;
            text-align: center;
        }

        #content {
            padding-left: 40px;
            transition: margin-left 0.3s ease;
        }

        #Text {
            display: flex;
            /*justify-content: center;*/
            /*align-items: center;*/
        }

        #butterflyChart {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #chart {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #map {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #footer {
            background-color: #333;
            color: #fff;
            padding: 20px;
            text-align: center;
        }

        .tooltip {
            position: absolute;
            pointer-events: none;
            background: #fff;
            border: 1px solid #ccc;
            padding: 8px;
            display: none;
        }
    </style>
</head>

<body>

<div id="header">
    <h1>On The Inside - Dominance and Glory in Formula 1</h1>
</div>

<div id="content">
    <h2>Welcome to the Formula 1 Dashboard</h2>

    <div id="mapSection">

        <div>
            <select id="mapViewSelect">
                <option value="1">Wins</option>
                <option value="2">Podiums</option>
                <option value="3">Poles</option>
            </select>
        </div>

        <br>

        <div>
            <select id="driverSelect">
                <option value="">Select Driver</option>
            </select>
        </div>

        <div id="map"></div>

        <div id="tooltip" style="position: absolute; opacity: 0;"></div>

    </div>

    <p>Select your desired driver to compare.</p>

    <div>
        <select id="driverSelect1">
            <option value="">Select driver 1</option>
        </select>
        <select id="driverSelect2">
            <option value="">Select driver 2</option>
        </select>
    </div>
</div>

<div id="Title">
    <h2>Driver Comparison</h2>
</div>

<div id="butterflyChart"></div>

<div id="Text">
        <h2><span style="margin-left: 400px;">Points Scored by Season</span> <span style="margin-left: 450px;">Most Fastest Laps</span></h2>
</div>

<div id="chart"></div>

<div id="footer">
    <p>2023 | On The Inside | Presented to you by Arif & Shuhail</p>
</div>

<script>
    let csvData = {}; // Object to hold the CSV data

    const driverSelect = document.getElementById("driverSelect");
    const mapViewSelect = document.getElementById("mapViewSelect");

    let mapView = 1;
    let selectedDriver = 0;

    // Function to handle parsed CSV data
    function handleCSVData(filename, results) {
        csvData[filename] = results.data; // Store the parsed data in the object
        // console.log(csvData); // Verify the data is stored correctly

        // Check if all CSV files are loaded and populate the driver dropdowns
        if (filename === "drivers.csv") {
            populateDriverDropdown();
            populateMapDriverDropdown();
        }
    }

    // Read and parse multiple CSV files
    const files = ["assets/data/circuits.csv", "assets/data/driver_standings.csv", "assets/data/drivers.csv", "assets/data/qualifying.csv",
                    "assets/data/races.csv", "assets/data/results.csv"];
    let fileCount = 0;

    files.forEach(function(file) {
        const filename = file.split('/').pop();
        fetch(file)
            .then(response => response.text())
            .then(csvContent => {
                Papa.parse(csvContent, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        // Handle the parsed data for each file
                        handleCSVData(filename, results);
                        fileCount++;

                        // Check if all CSV files are loaded and call the function to print driver results
                        if (fileCount === files.length) {
                        }
                    },
                    error: function(error) {
                        console.error("Error parsing file:", file);
                        console.error(error);
                    }
                });
            })
            .catch(error => {
                console.error("Error loading CSV file:", file);
                console.error(error);
            });
    });

    function populateMapDriverDropdown() {
        const driverData = csvData["drivers.csv"];

        driverData.sort(function(a, b) {
            // Sort the driverData array based on the first letter of the driver's name
            const nameA = a.forename.charAt(0).toUpperCase();
            const nameB = b.forename.charAt(0).toUpperCase();
            if (nameA < nameB) {
                return -1;
            }
            if (nameA > nameB) {
                return 1;
            }
            return 0;
        });

        driverData.forEach(function(driver) {
            const option = document.createElement("option");
            option.value = driver.driverId;
            option.text = driver.forename + " " + driver.surname;

            driverSelect.appendChild(option);
        });
    }

    // Function to populate the driver dropdowns
    function populateDriverDropdown() {
        const driverData = csvData["drivers.csv"];

        const driverSelect1 = document.getElementById("driverSelect1");
        const driverSelect2 = document.getElementById("driverSelect2");

        driverData.sort(function(a, b) {
            // Sort the driverData array based on the driver's name
            const nameA = a.forename.toUpperCase();
            const nameB = b.forename.toUpperCase();
            if (nameA < nameB) {
                return -1;
            }
            if (nameA > nameB) {
                return 1;
            }
            return 0;
        });

        driverData.forEach(function(driver) {
            const option1 = document.createElement("option");
            const option2 = document.createElement("option");
            option1.value = driver.driverId;
            option1.text = driver.forename + " " + driver.surname;
            option2.value = driver.driverId;
            option2.text = driver.forename + " " + driver.surname;
            driverSelect1.appendChild(option1);
            driverSelect2.appendChild(option2);
        });
    }

    // Function to update the butterfly chart
    function updateButterflyChart(driverId1, driverId2, chartContainerId) {

        const driverData = csvData["drivers.csv"];
        const driverResultsData = csvData["results.csv"];
        const qualifyingData = csvData["qualifying.csv"];

        // const driver1 = driverData.find(function (driver) {
        //     return driver.driverId === driverId1;
        // });
        //
        // const driver2 = driverData.find(function (driver) {
        //     return driver.driverId === driverId2;
        // });

        const driver1Results = driverResultsData.filter(function (result) {
            return result.driverId === driverId1;
        });

        const driver2Results = driverResultsData.filter(function (result) {
            return result.driverId === driverId2;
        });

        const driver1RaceCount = driver1Results.length;
        const driver2RaceCount = driver2Results.length;

        const driver1Wins = driverResultsData.filter(function (result) {
            return result.driverId === driverId1 && result.position === 1;
        }).length;

        const driver2Wins = driverResultsData.filter(function (result) {
            return result.driverId === driverId2 && result.position === 1;
        }).length;

        const driver1Podiums = driverResultsData.filter(function (result) {
            return result.driverId === driverId1 && result.position <= 3;
        }).length;

        const driver2Podiums = driverResultsData.filter(function (result) {
            return result.driverId === driverId2 && result.position <= 3;
        }).length;

        const driver1Poles = qualifyingData.filter(function (result) {
            return result.driverId === driverId1 && result.position === 1;
        }).length;

        const driver2Poles = qualifyingData.filter(function (result) {
            return result.driverId === driverId2 && result.position === 1;
        }).length;

        const chartContainer = document.getElementById(chartContainerId);
        chartContainer.innerHTML = "";

        const maxRaceCount = Math.max(driver1RaceCount, driver2RaceCount);
        const barWidthScale = d3.scaleLinear()
            .domain([0, maxRaceCount])
            .range([0, 150]);

        const svg = d3.select("#" + chartContainerId)
            .append("svg")
            .attr("width", 500)
            .attr("height", 300);

        // Driver 1 bar
        svg.append("rect")
            .attr("x", 190 - barWidthScale(driver1RaceCount))
            .attr("y", 25)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1RaceCount));

        svg.append("rect")
            .attr("x", 190 - barWidthScale(driver1Wins))
            .attr("y", 80)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Wins));

        svg.append("rect")
            .attr("x", 190 - barWidthScale(driver1Podiums))
            .attr("y", 135)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Podiums));

        svg.append("rect")
            .attr("x", 190 - barWidthScale(driver1Poles))
            .attr("y", 190)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Poles));

        // Driver 2 bar
        svg.append("rect")
            .attr("x", 305)
            .attr("y", 25)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2RaceCount));

        svg.append("rect")
            .attr("x", 305)
            .attr("y", 80)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Wins));

        svg.append("rect")
            .attr("x", 305)
            .attr("y", 135)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Podiums));

        svg.append("rect")
            .attr("x", 305)
            .attr("y", 190)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Poles));

        // Driver 1 text
        svg.append("text")
            .attr("x", 195 - barWidthScale(driver1RaceCount) - 25)
            .attr("y", 70)
            .attr("text-anchor", "middle")
            .text(driver1RaceCount)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 195 - barWidthScale(driver1Wins) - 25)
            .attr("y", 125)
            .attr("text-anchor", "middle")
            .text(driver1Wins)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 195 - barWidthScale(driver1Podiums) - 25)
            .attr("y", 175)
            .attr("text-anchor", "middle")
            .text(driver1Podiums)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 195 - barWidthScale(driver1Poles) - 25)
            .attr("y", 235)
            .attr("text-anchor", "middle")
            .text(driver1Poles)
            .style("fill", "#000");

        // Driver 2 text
        svg.append("text")
            .attr("x", 300 + barWidthScale(driver2RaceCount) + 25)
            .attr("y", 70)
            .attr("text-anchor", "middle")
            .text(driver2RaceCount)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 300 + barWidthScale(driver2Wins) + 25)
            .attr("y", 125)
            .attr("text-anchor", "middle")
            .text(driver2Wins)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 300 + barWidthScale(driver2Podiums) + 25)
            .attr("y", 175)
            .attr("text-anchor", "middle")
            .text(driver2Podiums)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 300 + barWidthScale(driver2Poles) + 25)
            .attr("y", 235)
            .attr("text-anchor", "middle")
            .text(driver2Poles)
            .style("fill", "#000"); /*gg*/

        svg.append("text")
            .attr("x", 250)
            .attr("y", 60)
            .attr("text-anchor", "middle")
            .text("Races")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 250)
            .attr("y", 110)
            .attr("text-anchor", "middle")
            .text("Wins")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 250)
            .attr("y", 170)
            .attr("text-anchor", "middle")
            .text("Podiums")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 250)
            .attr("y", 230)
            .attr("text-anchor", "middle")
            .text("Poles")
            .style("fill", "#000");
    }

    driverSelect1.addEventListener("change", function () {
        const selectedDriver1 = driverSelect1.value;
        const selectedDriver2 = driverSelect2.value;

        if (selectedDriver1 && selectedDriver2) {
            const desiredDriverId1 = parseInt(selectedDriver1);
            const desiredDriverId2 = parseInt(selectedDriver2);

            updateButterflyChart(desiredDriverId1, desiredDriverId2, "butterflyChart");
        }
    });

    driverSelect2.addEventListener("change", function () {
        const selectedDriver1 = driverSelect1.value;
        const selectedDriver2 = driverSelect2.value;

        if (selectedDriver1 && selectedDriver2) {
            const desiredDriverId1 = parseInt(selectedDriver1);
            const desiredDriverId2 = parseInt(selectedDriver2);

            updateButterflyChart(desiredDriverId1, desiredDriverId2, "butterflyChart");
        }
    });

    function updateMap(map, driverId, chartContainerId) {

        const driverData = csvData["drivers.csv"];
        const driverResultsData = csvData["results.csv"];
        const raceData = csvData["races.csv"];
        const circuitData = csvData["circuits.csv"];
        const qualifyingData = csvData["qualifying.csv"];

        if (driverId !== 0) {
            const driver = driverData.find(function (driver) {
                return driver.driverId === driverId;
            });

            const driverName = driver.forename + " " + driver.surname;
        }

        // Wins
        const driverWinData = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        })
        const winRaceIds = driverWinData.map(function (result) {
            return result.raceId;
        });
        const winRaces = raceData.filter(function (result) {
            return winRaceIds.includes(result.raceId);
        });
        const winCircuitIds = winRaces.map(function (result) {
            return result.circuitId;
        });
        const winCircuits = circuitData.filter(function (result) {
            return winCircuitIds.includes(result.circuitId);
        });

        const countryWins = {};
        winRaces.forEach(function (race) {
            const circuit = winCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryWins[country]) {
                    countryWins[country]++;
                } else {
                    countryWins[country] = 1;
                }
            }
        });

        // Podiums
        const driverPodiumData = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position <= 3;
        });
        const podiumRaceIds = driverPodiumData.map(function (result) {
            return result.raceId;
        });
        const podiumRaces = raceData.filter(function (result) {
            return podiumRaceIds.includes(result.raceId);
        });
        const podiumCircuitIds = podiumRaces.map(function (result) {
            return result.circuitId;
        });
        const podiumCircuits = circuitData.filter(function (result) {
            return podiumCircuitIds.includes(result.circuitId);
        });

        const countryPodiums = {};
        podiumRaces.forEach(function (race) {
            const circuit = podiumCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryPodiums[country]) {
                    countryPodiums[country]++;
                } else {
                    countryPodiums[country] = 1;
                }
            }
        });

        // Poles
        const driverPoleData = qualifyingData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        });
        const poleRaceIds = driverPoleData.map(function (result) {
            return result.raceId;
        });
        const poleRaces = raceData.filter(function (result) {
            return poleRaceIds.includes(result.raceId);
        });
        const poleCircuitIds = poleRaces.map(function (result) {
            return result.circuitId;
        });
        const poleCircuits = circuitData.filter(function (result) {
            return poleCircuitIds.includes(result.circuitId);
        });

        const countryPoles = {};
        poleRaces.forEach(function (race) {
            const circuit = poleCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryPoles[country]) {
                    countryPoles[country]++;
                } else {
                    countryPoles[country] = 1;
                }
            }
        });

        // Max values for scaling
        const maxWins = Math.max(...Object.values(countryWins));
        const maxPodiums = Math.max(...Object.values(countryPodiums));
        const maxPoles = Math.max(...Object.values(countryPoles));

        if (map === 1) {

            const chartContainer = document.getElementById(chartContainerId);
            chartContainer.innerHTML = "";

            const width = 1000;
            const height = 600;

            const svg = d3.select("#" + chartContainerId)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Define the projection for the map (you can choose a different one if desired)
            const projection = d3.geoMercator()
                .scale(130)
                .translate([width / 2, height / 1.4]);

            // Create a path generator
            const path = d3.geoPath().projection(projection);
            const tooltip = d3.select("#tooltip");

            // Load the map data
            d3.json("assets/data/countries.geojson").then(function(mapData) {
                // Draw the map
                svg.selectAll("path")
                    .data(mapData.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", function(d) {
                        // Lookup the number of wins for the current country
                        const wins = countryWins[d.properties.ADMIN];
                        if (wins) {
                            // Replace the color based on the number of wins
                            return d3.interpolateReds(wins / maxWins);
                        } else {
                            return "#ccc"; // Default color for countries without data
                        }
                    })
                    // Add hover actions and tooltip display
                    .on("mouseover", function(event, d) {
                        // Increase the opacity of the hovered country
                        d3.select(this).style("opacity", 0.7);

                        const wins = countryWins[d.properties.ADMIN];
                        const winsText = wins !== null && wins !== undefined ? wins : 0;

                        // Position and display the tooltip
                        tooltip.style("left", event.pageX + "px")
                            .style("top", event.pageY + "px")
                            .style("opacity", 1)
                            .html(`<strong>${d.properties.ADMIN}</strong><br>Wins: ${winsText}`);
                    })
                    .on("mouseout", function() {
                        // Reset the opacity and hide the tooltip
                        d3.select(this).style("opacity", 1);
                        tooltip.style("opacity", 0);
                    });
            });

            // Create a zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 8]) // Set the zoom scale range
                .on("zoom", zoomed);

            // Apply the zoom behavior to the SVG container
            svg.call(zoom);

            // Define the zoom handler function
            function zoomed(event) {
                // Get the current zoom transformation
                const { transform } = event;

                // Apply the transformation to the map features
                svg.selectAll("path")
                    .attr("transform", transform);
            }

            // Add a listener for the mouse scroll event
            svg.on("wheel", function(event) {
                // Prevent the default scroll behavior
                event.preventDefault();

                // Get the current zoom scale
                const currentScale = d3.zoomTransform(this).k;

                // Calculate the new scale based on the scroll event
                const newScale = currentScale - event.deltaY * 0.01;

                // Apply the new scale with a smooth transition
                svg.transition().duration(200).call(zoom.scaleTo, newScale);
            });

        } else if (map === 2) {

            const chartContainer = document.getElementById(chartContainerId);
            chartContainer.innerHTML = "";

            const width = 1000;
            const height = 600;

            const svg = d3.select("#" + chartContainerId)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Define the projection for the map (you can choose a different one if desired)
            const projection = d3.geoMercator()
                .scale(130)
                .translate([width / 2, height / 1.4]);

            // Create a path generator
            const path = d3.geoPath().projection(projection);
            const tooltip = d3.select("#tooltip");

            // Load the map data
            d3.json("assets/data/countries.geojson").then(function(mapData) {
                // Draw the map
                svg.selectAll("path")
                    .data(mapData.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", function(d) {
                        // Lookup the number of podiums for the current country
                        const podiums = countryPodiums[d.properties.ADMIN];
                        if (podiums) {
                            // Replace the color based on the number of podiums
                            return d3.interpolateGreens(podiums / maxPodiums);
                        } else {
                            return "#ccc"; // Default color for countries without data
                        }
                    })
                    // Add hover actions and tooltip display
                    .on("mouseover", function(event, d) {
                        // Increase the opacity of the hovered country
                        d3.select(this).style("opacity", 0.7);

                        const podiums = countryPodiums[d.properties.ADMIN];
                        const podiumsText = podiums !== null && podiums !== undefined ? podiums : 0;

                        // Position and display the tooltip
                        tooltip.style("left", event.pageX + "px")
                            .style("top", event.pageY + "px")
                            .style("opacity", 1)
                            .html(`<strong>${d.properties.ADMIN}</strong><br>Podiums: ${podiumsText}`);
                    })
                    .on("mouseout", function() {
                        // Reset the opacity and hide the tooltip
                        d3.select(this).style("opacity", 1);
                        tooltip.style("opacity", 0);
                    });
            });

            // Create a zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 8]) // Set the zoom scale range
                .on("zoom", zoomed);

            // Apply the zoom behavior to the SVG container
            svg.call(zoom);

            // Define the zoom handler function
            function zoomed(event) {
                // Get the current zoom transformation
                const { transform } = event;

                // Apply the transformation to the map features
                svg.selectAll("path")
                    .attr("transform", transform);
            }

            // Add a listener for the mouse scroll event
            svg.on("wheel", function(event) {
                // Prevent the default scroll behavior
                event.preventDefault();

                // Get the current zoom scale
                const currentScale = d3.zoomTransform(this).k;

                // Calculate the new scale based on the scroll event
                const newScale = currentScale - event.deltaY * 0.01;

                // Apply the new scale with a smooth transition
                svg.transition().duration(200).call(zoom.scaleTo, newScale);
            });

        } else if (map === 3) {

            const chartContainer = document.getElementById(chartContainerId);
            chartContainer.innerHTML = "";

            const width = 1000;
            const height = 600;

            const svg = d3.select("#" + chartContainerId)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            // Define the projection for the map (you can choose a different one if desired)
            const projection = d3.geoMercator()
                .scale(130)
                .translate([width / 2, height / 1.4]);

            // Create a path generator
            const path = d3.geoPath().projection(projection);
            const tooltip = d3.select("#tooltip");

            // Load the map data
            d3.json("assets/data/countries.geojson").then(function(mapData) {
                // Draw the map
                svg.selectAll("path")
                    .data(mapData.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", function(d) {
                        // Lookup the number of poles for the current country
                        const poles = countryPoles[d.properties.ADMIN];
                        if (poles) {
                            // Replace the color based on the number of wins
                            return d3.interpolateBlues(poles / maxPoles);
                        } else {
                            return "#ccc"; // Default color for countries without data
                        }
                    })
                    // Add hover actions and tooltip display
                    .on("mouseover", function(event, d) {
                        // Increase the opacity of the hovered country
                        d3.select(this).style("opacity", 0.7);

                        const poles = countryPoles[d.properties.ADMIN];
                        const polesText = poles !== null && poles !== undefined ? poles : 0;

                        // Position and display the tooltip
                        tooltip.style("left", event.pageX + "px")
                            .style("top", event.pageY + "px")
                            .style("opacity", 1)
                            .html(`<strong>${d.properties.ADMIN}</strong><br>Poles: ${polesText}`);
                    })
                    .on("mouseout", function() {
                        // Reset the opacity and hide the tooltip
                        d3.select(this).style("opacity", 1);
                        tooltip.style("opacity", 0);
                    });
            });

            // Create a zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 8]) // Set the zoom scale range
                .on("zoom", zoomed);

            // Apply the zoom behavior to the SVG container
            svg.call(zoom);

            // Define the zoom handler function
            function zoomed(event) {
                // Get the current zoom transformation
                const { transform } = event;

                // Apply the transformation to the map features
                svg.selectAll("path")
                    .attr("transform", transform);
            }

            // Add a listener for the mouse scroll event
            svg.on("wheel", function(event) {
                // Prevent the default scroll behavior
                event.preventDefault();

                // Get the current zoom scale
                const currentScale = d3.zoomTransform(this).k;

                // Calculate the new scale based on the scroll event
                const newScale = currentScale - event.deltaY * 0.01;

                // Apply the new scale with a smooth transition
                svg.transition().duration(200).call(zoom.scaleTo, newScale);
            });

        }

    }

    mapViewSelect.addEventListener("change", function() {
        const map = mapViewSelect.value;

        if (map) {
            if (selectedDriver === 0) {
                updateMap(0, selectedDriver, "map");
            } else {
                mapView = parseInt(map);
                updateMap(mapView, selectedDriver, "map");
            }
        }
    });

    driverSelect.addEventListener("change", function () {
        const driver = driverSelect.value;

        if (driver) {
            selectedDriver = parseInt(driver);
            updateMap(mapView, selectedDriver, "map");
        }
    });

</script>

<!--Script for Point Scored by a Season-->
<script>

    // Load the CSV data using PapaParse
    Papa.parse("assets/data/drivers.csv", {
        header: true,
        download: true,
        complete: function (driversData) {
            // Store the drivers data in an object for easy access
            const drivers = driversData.data.reduce((acc, driver) => {
                acc[driver.driverId] = driver.forename + " " + driver.surname;
                return acc;
            }, {});


            // Load the race data
            Papa.parse("assets/data/races.csv", {
                header: true,
                download: true,
                complete: function (racesData) {
                    // Store the races data in an object for easy access
                    const races = racesData.data.reduce((acc, race) => {
                        acc[race.raceId] = race.year;
                        return acc;
                    }, {});

                    // Load the result data
                    Papa.parse("assets/data/results.csv", {
                        header: true,
                        download: true,
                        complete: function (resultsData) {
                            // Function to get points scored by year for a driver
                            function getPointsByYear(driverId) {
                                const driverPointsByYear = {};

                                // Filter results based on driver ID
                                const driverResults = resultsData.data.filter(
                                    (result) => result.driverId === driverId
                                );

                                // Calculate points scored by year
                                driverResults.forEach((result) => {
                                    const raceYear = races[result.raceId];
                                    const points = parseInt(result.points);

                                    if (driverPointsByYear[raceYear]) {
                                        driverPointsByYear[raceYear] += points;
                                    } else {
                                        driverPointsByYear[raceYear] = points;
                                    }
                                });

                                return driverPointsByYear;
                            }

                            // Set up dimensions
                            const width = 800;
                            const height = 300;
                            const margin = { top: 20, right: 20, bottom: 30, left: 50 };
                            const innerWidth = width - margin.left - margin.right;
                            const innerHeight = height - margin.top - margin.bottom;

                            // Create SVG element
                            const svg = d3
                                .select("#chart")
                                .append("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                .attr("transform", `translate(${margin.left}, ${margin.top})`);

                            // Set up scales
                            const xScale = d3.scaleBand().range([0, innerWidth]).padding(0.1);
                            const yScale = d3.scaleLinear().range([innerHeight, 0]);

                            // Define the line
                            const line = d3
                                .line()
                                .x((d) => xScale(d.year) + xScale.bandwidth() / 2)
                                .y((d) => yScale(d.points));

                            // Add x-axis
                            svg
                                .append("g")
                                .attr("class", "x-axis")
                                .attr("transform", `translate(0, ${innerHeight})`);

                            // Add y-axis
                            svg.append("g").attr("class", "y-axis");

                            // Add tooltip
                            const tooltip = d3
                                .select("body")
                                .append("div")
                                .attr("class", "tooltip");

                            // Function to update the chart based on selected drivers
                            function updateChart() {
                                const driverId1 = driverSelect1.value;
                                const driverId2 = driverSelect2.value;

                                const driver1PointsByYear = getPointsByYear(driverId1);
                                const driver2PointsByYear = getPointsByYear(driverId2);

                                const driver1Data = Object.keys(driver1PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver1PointsByYear[year],
                                    driver: 1,
                                }));

                                const driver2Data = Object.keys(driver2PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver2PointsByYear[year],
                                    driver: 2,
                                }));

                                const data = driver1Data.concat(driver2Data);

                                // Sort the data by year in ascending order
                                data.sort((a, b) => a.year - b.year);

                                // Update x-scale domain
                                xScale.domain(data.map((d) => d.year));

                                // Update y-scale domain
                                yScale.domain([0, d3.max(data, (d) => d.points)]);

                                // Update x-axis
                                svg.select(".x-axis").call(d3.axisBottom(xScale));

                                // Update y-axis
                                svg.select(".y-axis").call(d3.axisLeft(yScale));

                                // Remove any existing lines
                                svg.selectAll(".line").remove();

                                // Add the line for driver 1
                                svg.append("path")
                                    .datum(driver1Data)
                                    .attr("class", "line line1")
                                    .attr("fill", "none")
                                    .attr("stroke", "#377eb8")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .each(function () {
                                        const path = d3.select(this);
                                        const totalLength = path.node().getTotalLength();

                                        path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                            .attr("stroke-dashoffset", totalLength)
                                            .transition()
                                            .duration(2000)
                                            .attr("stroke-dashoffset", 0);
                                    });

                                // Add the line for driver 2 with line drawing animation
                                svg.append("path")
                                    .datum(driver2Data)
                                    .attr("class", "line line2")
                                    .attr("fill", "none")
                                    .attr("stroke", "#e41a1c")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .each(function () {
                                        const path = d3.select(this);
                                        const totalLength = path.node().getTotalLength();

                                        path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                            .attr("stroke-dashoffset", totalLength)
                                            .transition()
                                            .duration(2000)
                                            .attr("stroke-dashoffset", 0);
                                    });

                                // Remove any existing dots
                                svg.selectAll(".dot").remove();

                                // Add the dots for each data point
                                svg
                                    .selectAll(".dot")
                                    .data(data)
                                    .enter()
                                    .append("circle")
                                    .attr("class", "dot")
                                    .attr("cx", (d) => xScale(d.year) + xScale.bandwidth() / 2)
                                    .attr("cy", (d) => yScale(d.points))
                                    .attr("r", 4)
                                    .attr("fill", (d) => (d.driver === 1 ? "#377eb8" : "#e41a1c"))
                                    .on("mouseover", (event, d) => {
                                        tooltip
                                            .style("display", "block")
                                            .style("left", event.pageX + 10 + "px")
                                            .style("top", event.pageY - 10 + "px")
                                            .html(`Year: ${d.year}<br/>Points: ${d.points}`);
                                    })
                                    .on("mouseout", () => {
                                        tooltip.style("display", "none");
                                    });
                            }
                            // Listen for change in driver selection
                            const driverSelect1 = document.getElementById("driverSelect1");
                            const driverSelect2 = document.getElementById("driverSelect2");

                            driverSelect1.addEventListener("change", updateChart);
                            driverSelect2.addEventListener("change", updateChart);

                            // Initialize the chart with default drivers
                            updateChart();
                        },
                    });
                },
            });
        },
    });
</script>


<!--Script for Most Fastest Laps by a Season-->
<script>
    // Load the CSV data using PapaParse
    Papa.parse("assets/data/drivers.csv", {
        header: true,
        download: true,
        complete: function (driversData) {
            // Store the drivers data in an object for easy access
            const drivers = driversData.data.reduce((acc, driver) => {
                acc[driver.driverId] = driver.forename + " " + driver.surname;
                return acc;
            }, {});

            // Load the race data
            Papa.parse("assets/data/races.csv", {
                header: true,
                download: true,
                complete: function (racesData) {
                    // Store the races data in an object for easy access
                    const races = racesData.data.reduce((acc, race) => {
                        acc[race.raceId] = race.year;
                        return acc;
                    }, {});

                    // Load the result data
                    Papa.parse("assets/data/results.csv", {
                        header: true,
                        download: true,
                        complete: function (resultsData) {
                            // Function to count rank 1 finishes by year for a driver
                            function countRank1ByYear(driverId) {
                                const rank1CountByYear = {};

                                // Filter results based on driver ID and rank 1
                                const driverResults = resultsData.data.filter(
                                    (result) => result.driverId === driverId && result.rank === "1"
                                );

                                // Count rank 1 finishes by year
                                driverResults.forEach((result) => {
                                    const raceYear = races[result.raceId];

                                    if (rank1CountByYear[raceYear]) {
                                        rank1CountByYear[raceYear] += 1;
                                    } else {
                                        rank1CountByYear[raceYear] = 1;
                                    }
                                });

                                return rank1CountByYear;
                            }

                            // Set up dimensions
                            const width = 800;
                            const height = 300;
                            const margin = { top: 20, right: 20, bottom: 30, left: 80 };
                            const innerWidth = width - margin.left - margin.right;
                            const innerHeight = height - margin.top - margin.bottom;

                            // Create SVG element
                            const svg = d3
                                .select("#chart")
                                .append("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                .attr("transform", `translate(${margin.left}, ${margin.top})`);

                            // Set up scales
                            const xScale = d3.scaleBand().range([0, innerWidth]).padding(0.1);
                            const yScale = d3.scaleLinear().range([innerHeight, 0]);

                            // Define the line
                            const line = d3
                                .line()
                                .x((d) => xScale(d.year) + xScale.bandwidth() / 2)
                                .y((d) => yScale(d.points));

                            // Add x-axis
                            svg
                                .append("g")
                                .attr("class", "x-axis")
                                .attr("transform", `translate(0, ${innerHeight})`);

                            // Add y-axis
                            svg.append("g").attr("class", "y-axis");

                            const tooltip = d3
                                .select("body")
                                .append("div")
                                .attr("class", "tooltip");

                            // Function to update the chart based on selected drivers
                            function updateChart2() {
                                const driverId1 = driverSelect1.value;
                                const driverId2 = driverSelect2.value;

                                const driver1PointsByYear = countRank1ByYear(driverId1);
                                const driver2PointsByYear = countRank1ByYear(driverId2);

                                const driver1Data = Object.keys(driver1PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver1PointsByYear[year],
                                    driver: 1,
                                }));

                                const driver2Data = Object.keys(driver2PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver2PointsByYear[year],
                                    driver: 2,
                                }));

                                const data = driver1Data.concat(driver2Data);

                                // Sort the data by year in ascending order
                                data.sort((a, b) => a.year - b.year);

                                // Update x-scale domain
                                xScale.domain(data.map((d) => d.year));

                                // Update y-scale domain
                                yScale.domain([0, d3.max(data, (d) => d.points)]);

                                // Update x-axis
                                svg.select(".x-axis").call(d3.axisBottom(xScale));

                                // Update y-axis
                                svg.select(".y-axis").call(d3.axisLeft(yScale));

                                // Remove any existing lines
                                svg.selectAll(".line").remove();

                                // Add the line for driver 1
                                svg.append("path")
                                    .datum(driver1Data)
                                    .attr("class", "line line1")
                                    .attr("fill", "none")
                                    .attr("stroke", "#377eb8")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .call(animateLine);

                                // Add the line for driver 2 with line drawing animation
                                svg.append("path")
                                    .datum(driver2Data)
                                    .attr("class", "line line2")
                                    .attr("fill", "none")
                                    .attr("stroke", "#e41a1c")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .call(animateLine);

                                // Function to animate the line drawing
                                function animateLine(path) {
                                    const totalLength = path.node().getTotalLength();

                                    path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                        .attr("stroke-dashoffset", totalLength)
                                        .transition()
                                        .duration(2000)
                                        .ease(d3.easeLinear)
                                        .attr("stroke-dashoffset", 0);
                                }

                                // Remove any existing dots
                                svg.selectAll(".dot").remove();

                                // Add the dots for each data point
                                svg
                                    .selectAll(".dot")
                                    .data(data)
                                    .enter()
                                    .append("circle")
                                    .attr("class", "dot")
                                    .attr("cx", (d) => xScale(d.year) + xScale.bandwidth() / 2)
                                    .attr("cy", (d) => yScale(d.points))
                                    .attr("r", 4)
                                    .attr("fill", (d) => (d.driver === 1 ? "#377eb8" : "#e41a1c"))
                                    .on("mouseover", (event, d) => {
                                        tooltip
                                            .style("display", "block")
                                            .style("left", event.pageX + 10 + "px")
                                            .style("top", event.pageY - 10 + "px")
                                            .html(`Year: ${d.year}<br/>Fastest Lap: ${d.points}`);
                                    })
                                    .on("mouseout", () => {
                                        tooltip.style("display", "none");
                                    });
                            }

                            // Listen for change in driver selection
                            const driverSelect1 = document.getElementById("driverSelect1");
                            const driverSelect2 = document.getElementById("driverSelect2");

                            driverSelect1.addEventListener("change", updateChart2);
                            driverSelect2.addEventListener("change", updateChart2);

                            // Initialize the chart with default drivers
                            updateChart2();
                        },
                    });
                },
            });
        },
    });
</script>

</body>
</html>