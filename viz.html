<!DOCTYPE html>
<html>
<head>
    <title>On The Inside</title>
    <link rel="icon" type="image/x-icon" href="https://cdn-icons-png.flaticon.com/512/2418/2418779.png">
    <link rel="stylesheet" href="assets/css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.0"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-zoom.v3.min.js"></script>

    <style>
        @font-face {
            font-family: 'F1_Regular';
            src: url('assets/fonts/Formula1-Regular_web_0.ttf') format('truetype');
        }

        @font-face {
            font-family: 'F1_Bold';
            src: url('assets/fonts/Formula1-Bold_web_0.ttf') format('truetype');
        }

        @font-face {
            font-family: 'F1_Wide';
            src: url('assets/fonts/Formula1-Wide_web_0.ttf') format('truetype');
        }

        #butterflyChart {
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
<div id="header">
    <h1>On The Inside - Dominance and Glory in Formula 1</h1>
</div>
<div id="content">
    <h2>Welcome to the Formula 1 Dashboard</h2>
    <p>Select a menu option to view the desired information.</p>

    <div>
        <select id="driverSelect1">
            <option value="">Select driver 1</option>
        </select>
        <select id="driverSelect2">
            <option value="">Select driver 2</option>
        </select>
    </div>
</div>

<div id="map"></div>

<div id="tooltip" style="position: absolute; opacity: 0;"></div>

<div id="footer">
    <p>2023 | On The Inside | Presented to you by Arif & Shuhail</p>
</div>

<script>
    let csvData = {}; // Object to hold the CSV data
    const driverSelect1 = document.getElementById("driverSelect1");
    const driverSelect2 = document.getElementById("driverSelect2");

    // Function to handle parsed CSV data
    function handleCSVData(filename, results) {
        csvData[filename] = results.data; // Store the parsed data in the object
        console.log(csvData); // Verify the data is stored correctly

        // Check if all CSV files are loaded and populate the driver dropdowns
        if (filename === "drivers.csv") {
            populateDriverDropdown();
        }
    }

    // Read and parse multiple CSV files
    const files = ["assets/data/circuits.csv", "assets/data/drivers.csv", "assets/data/results.csv", "assets/data/races.csv", "assets/data/driver_standings.csv" , "assets/data/qualifying.csv"];
    let fileCount = 0;

    // Function to populate the driver dropdowns
    function populateDriverDropdown() {
        const driverData = csvData["drivers.csv"];

        driverData.sort(function(a, b) {
            // Sort the driverData array based on the first letter of the driver's name
            const nameA = a.forename.charAt(0).toUpperCase();
            const nameB = b.forename.charAt(0).toUpperCase();
            if (nameA < nameB) {
                return -1;
            }
            if (nameA > nameB) {
                return 1;
            }
            return 0;
        });

        driverData.forEach(function(driver) {
            const option1 = document.createElement("option");
            const option2 = document.createElement("option");
            option1.value = driver.driverId;
            option1.text = driver.forename + " " + driver.surname;
            option2.value = driver.driverId;
            option2.text = driver.forename + " " + driver.surname;
            driverSelect1.appendChild(option1);
            driverSelect2.appendChild(option2);
        });
    }

    files.forEach(function(file) {
        const filename = file.split('/').pop();
        fetch(file)
            .then(response => response.text())
            .then(csvContent => {
                Papa.parse(csvContent, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        // Handle the parsed data for each file
                        handleCSVData(filename, results);
                        fileCount++;

                        // Check if all CSV files are loaded and call the function to print driver results
                        if (fileCount === files.length) {
                            updateBarChart();
                        }
                    },
                    error: function(error) {
                        console.error("Error parsing file:", file);
                        console.error(error);
                    }
                });
            })
            .catch(error => {
                console.error("Error loading CSV file:", file);
                console.error(error);
            });
    });

    // Function to update the map visualization
    function updateWinMap(driverId, chartContainerId) {

        const driverData = csvData["drivers.csv"];
        const driverResultsData = csvData["results.csv"];
        const raceData = csvData["races.csv"];
        const circuitData = csvData["circuits.csv"];

        const driver = driverData.find(function (driver) {
            return driver.driverId === driverId;
        });

        const driverWins = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        }).length;

        const driverWinData = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        })

        const winRaceIds = driverWinData.map(function (result) {
            return result.raceId;
        });

        const winRaces = raceData.filter(function (result) {
            return winRaceIds.includes(result.raceId);
        });

        const winCircuitIds = winRaces.map(function (result) {
            return result.circuitId;
        });

        const winCircuits = circuitData.filter(function (result) {
            return winCircuitIds.includes(result.circuitId);
        });

        const countryWins = {};

        winRaces.forEach(function (race) {
            const circuit = winCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryWins[country]) {
                    countryWins[country]++;
                } else {
                    countryWins[country] = 1;
                }
            }
        });

        // Calculate the maximum number of wins
        const maxWins = Math.max(...Object.values(countryWins));

        const chartContainer = document.getElementById(chartContainerId);
        chartContainer.innerHTML = "";

        const width = 800;
        const height = 400;

        const svg = d3.select("#" + chartContainerId)
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Define the projection for the map (you can choose a different one if desired)
        const projection = d3.geoMercator()
            .scale(130)
            .translate([width / 2, height / 1.4]);

        // Create a path generator
        const path = d3.geoPath().projection(projection);

        // Load the map data
        d3.json("assets/data/countries.geojson").then(function(mapData) {
            // Draw the map
            svg.selectAll("path")
                .data(mapData.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("fill", function(d) {
                    // Lookup the number of wins for the current country
                    const wins = countryWins[d.properties.ADMIN];
                    if (wins) {
                        // Replace the color based on the number of wins
                        return d3.interpolateReds(wins / maxWins);
                    } else {
                        return "#ccc"; // Default color for countries without data
                    }
                });
        });

    }

    // Function to update the map visualization
    function updatePodiumMap(driverId, chartContainerId) {

        const driverData = csvData["drivers.csv"];
        const driverResultsData = csvData["results.csv"];
        const raceData = csvData["races.csv"];
        const circuitData = csvData["circuits.csv"];

        const driver = driverData.find(function (driver) {
            return driver.driverId === driverId;
        });

        const driverPodiums = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position <= 3;
        }).length;

        const driverPodiumData = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position <= 3;
        });

        const podiumRaceIds = driverPodiumData.map(function (result) {
            return result.raceId;
        });

        const podiumRaces = raceData.filter(function (result) {
            return podiumRaceIds.includes(result.raceId);
        });

        const podiumCircuitIds = podiumRaces.map(function (result) {
            return result.circuitId;
        });

        const podiumCircuits = circuitData.filter(function (result) {
            return podiumCircuitIds.includes(result.circuitId);
        });

        const countryPodiums = {};

        podiumRaces.forEach(function (race) {
            const circuit = podiumCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryPodiums[country]) {
                    countryPodiums[country]++;
                } else {
                    countryPodiums[country] = 1;
                }
            }
        });

        console.log(countryPodiums);

        // Calculate the maximum number of wins
        const maxPodiums = Math.max(...Object.values(countryPodiums));

        const chartContainer = document.getElementById(chartContainerId);
        chartContainer.innerHTML = "";

        const width = 800;
        const height = 400;

        const svg = d3.select("#" + chartContainerId)
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Define the projection for the map (you can choose a different one if desired)
        const projection = d3.geoMercator()
            .scale(130)
            .translate([width / 2, height / 1.4]);

        // Select the tooltip element
        const tooltip = d3.select("#tooltip");

        // Create a path generator
        const path = d3.geoPath().projection(projection);

        // Load the map data
        d3.json("assets/data/countries.geojson").then(function(mapData) {
            // Draw the map
            svg.selectAll("path")
                .data(mapData.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("fill", function(d) {
                    // Lookup the number of podiums for the current country
                    const podiums = countryPodiums[d.properties.ADMIN];
                    if (podiums) {
                        // Replace the color based on the number of podiums
                        return d3.interpolateGreens(podiums / maxPodiums);
                    } else {
                        return "#ccc"; // Default color for countries without data
                    }
                })
                // Add hover actions and tooltip display
                .on("mouseover", function(event, d) {
                    // Increase the opacity of the hovered country
                    d3.select(this).style("opacity", 0.7);

                    const podiums = countryPodiums[d.properties.ADMIN];
                    const podiumsText = podiums !== null && podiums !== undefined ? podiums : 0;

                    // Position and display the tooltip
                    tooltip.style("left", event.pageX + "px")
                        .style("top", event.pageY + "px")
                        .style("opacity", 1)
                        .html(`<strong>${d.properties.ADMIN}</strong><br>Podiums: ${podiumsText}`);
                })
                .on("mouseout", function() {
                    // Reset the opacity and hide the tooltip
                    d3.select(this).style("opacity", 1);
                    tooltip.style("opacity", 0);
                });
        });

        // Create a zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([1, 8]) // Set the zoom scale range
            .on("zoom", zoomed);

        // Apply the zoom behavior to the SVG container
        svg.call(zoom);

        // Define the zoom handler function
        function zoomed(event) {
            // Get the current zoom transformation
            const { transform } = event;

            // Apply the transformation to the map features
            svg.selectAll("path")
                .attr("transform", transform);
        }

        // Add a listener for the mouse scroll event
        svg.on("wheel", function(event) {
            // Prevent the default scroll behavior
            event.preventDefault();

            // Get the current zoom scale
            const currentScale = d3.zoomTransform(this).k;

            // Calculate the new scale based on the scroll event
            const newScale = currentScale - event.deltaY * 0.01;

            // Apply the new scale with a smooth transition
            svg.transition().duration(200).call(zoom.scaleTo, newScale);
        });

    }

    function updatePoleMap(driverId, chartContainerId) {

        const driverData = csvData["drivers.csv"];
        const raceData = csvData["races.csv"];
        const circuitData = csvData["circuits.csv"];
        const qualifyingData = csvData["qualifying.csv"];

        const driver = driverData.find(function (driver) {
            return driver.driverId === driverId;
        });

        const driverPoles = qualifyingData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        }).length;

        const driverPoleData = qualifyingData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        });

        const poleRaceIds = driverPoleData.map(function (result) {
            return result.raceId;
        });

        const poleRaces = raceData.filter(function (result) {
            return poleRaceIds.includes(result.raceId);
        });

        const poleCircuitIds = poleRaces.map(function (result) {
            return result.circuitId;
        });

        const poleCircuits = circuitData.filter(function (result) {
            return poleCircuitIds.includes(result.circuitId);
        });

        const countryPoles = {};

        poleRaces.forEach(function (race) {
            const circuit = poleCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryPoles[country]) {
                    countryPoles[country]++;
                } else {
                    countryPoles[country] = 1;
                }
            }
        });

        // Calculate the maximum number of wins
        const maxPoles = Math.max(...Object.values(countryPoles));

        console.log(countryPoles);

        const chartContainer = document.getElementById(chartContainerId);
        chartContainer.innerHTML = "";

        const width = 800;
        const height = 400;

        const svg = d3.select("#" + chartContainerId)
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Define the projection for the map (you can choose a different one if desired)
        const projection = d3.geoMercator()
            .scale(130)
            .translate([width / 2, height / 1.4]);

        // Create a path generator
        const path = d3.geoPath().projection(projection);

        // Load the map data
        d3.json("assets/data/countries.geojson").then(function(mapData) {
            // Draw the map
            svg.selectAll("path")
                .data(mapData.features)
                .enter()
                .append("path")
                .attr("d", path)
                .attr("fill", function(d) {
                    // Lookup the number of podiums for the current country
                    const poles = countryPoles[d.properties.ADMIN];
                    if (poles) {
                        // Replace the color based on the number of podiums
                        return d3.interpolateBlues(poles / maxPoles);
                    } else {
                        return "#ccc"; // Default color for countries without data
                    }
                });
        });

    }

    driverSelect1.addEventListener("change", function () {
        const selectedDriver1 = driverSelect1.value;
        const selectedDriver2 = driverSelect2.value;

        if (selectedDriver1 && selectedDriver2) {
            const desiredDriverId1 = parseInt(selectedDriver1);
            const desiredDriverId2 = parseInt(selectedDriver2);

            // updateWinMap(desiredDriverId1, "map");
            // updatePodiumMap(desiredDriverId1, "map");
            updatePoleMap(desiredDriverId1, "map");
        }
    });

    driverSelect2.addEventListener("change", function () {
        const selectedDriver1 = driverSelect1.value;
        const selectedDriver2 = driverSelect2.value;

        if (selectedDriver1 && selectedDriver2) {
            const desiredDriverId1 = parseInt(selectedDriver1);
            const desiredDriverId2 = parseInt(selectedDriver2);

            updatePodiumMap(desiredDriverId2, "map");
        }
    });

</script>

</body>
</html>
