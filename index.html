<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8">
    <title>On The Inside</title>
    <link rel="icon" type="image/x-icon" href="https://cdn-icons-png.flaticon.com/512/2418/2418779.png">

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.7.0/d3.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-zoom.v3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3.layout.cloud.js"></script>
    <link rel="stylesheet" href="assets/css/style.css">

    <style>
        @font-face {
            font-family: 'F1_Regular';
            src: url('assets/fonts/Formula1-Regular_web_0.ttf') format('truetype');
        }

        @font-face {
            font-family: 'F1_Bold';
            src: url('assets/fonts/Formula1-Bold_web_0.ttf') format('truetype');
        }

        @font-face {
            font-family: 'F1_Wide';
            src: url('assets/fonts/Formula1-Wide_web_0.ttf') format('truetype');
        }
    </style>

</head>

<body>

<div id="header">
    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/33/F1.svg/1024px-F1.svg.png" alt="F1 Logo" class="header_logo">
    <h1>On The Inside - </h1>
    <h2>Dominance and Glory in Formula 1</h2>
</div>

<br><br><br>

<!-- Overview Section -->

<div class="subheader">
    <h1>Driver & Constructor Overview</h1>
</div>

<div class="container">

    <div class="left">

        <div id="chart" class="chart"></div>

    </div>

    <div class="right">

        <div class="top-section">
            <div class="range-slider">
                <div class="arrow" id="prevYear">&lt;</div>
                <input type="range" id="year" name="year" min="1950" max="2022" value="2007">
                <div class="arrow" id="nextYear">&gt;</div>
                <div id="selectedYearDisplay"></div>
            </div>
        </div>

        <div class="bottom-section">
            <div class="box-container">
                <div class="box-row">
                    <div id="highestPointsDisplay" class="info-box driver-champion">
                        <h3>Driver <br> Champion</h3>
                        <p id="highestPointsDriver"></p>
                    </div>
                    <div id="constructorDisplay" class="info-box constructor-champion">
                        <h3>Constructor Champion</h3>
                        <p id="highestPointsConstructor"></p>
                    </div>
                </div>
                <div class="box-row">
                    <div id="mostPodiumFinishesDisplay" class="info-box most-podiums">
                        <h3>Most <br> Podiums</h3>
                        <p id="mostPodiumFinishesDriver"></p>
                    </div>
                    <div id="mostFastestLapsDisplay" class="info-box most-fastest-laps">
                        <h3>Most <br> Fastest Laps</h3>
                        <p id="mostFastestLapsDriver"></p>
                    </div>
                </div>
            </div>
        </div>

    </div>

</div>

<!-- End -->

<hr class="line-break">

<!-- Map Section -->

<div class="map_container">

    <div class="map_filter">
        <div class="dropdown_left">
            <div>
                <select id="mapViewSelect">
                    <option value="1">Wins</option>
                    <option value="2">Podiums</option>
                    <option value="3">Poles</option>
                </select>
            </div>
        </div>
        <div class="dropdown_right">
            <div>
                <select id="driverSelect">
                    <option value="">Select Driver</option>
                </select>
            </div>
        </div>
    </div>

    <br>

    <div class="map_viz">
        <div id="map"></div>
        <!-- <div id="map_legend"></div> -->
        <div id="tooltip" style="position: absolute; opacity: 0;"></div>
    </div>

</div>

<!-- End -->

<hr class="line-break">

<!-- Constructor Section -->

<div class="constructor_section">

    <div id="wordCloudChart" class="word_cloud"></div>
    <div id="tooltip_word" style="position: absolute; opacity: 0; pointer-events: none;"></div>
    <div class="constructor_info">
        <div class="info-box-row-top">
            <div id="totalPoints" class="info-box-ind">
                <h2>Total Points</h2>
                <p id="constPoints"></p>
            </div>
            <div id="totalWins" class="info-box-ind">
                <h2>Total Wins</h2>
                <p id="constWins"></p>
            </div>
        </div>
        <div class="info-box-row-bottom">
            <div id="totalPodiums" class="info-box-ind">
                <h2>Total Podiums</h2>
                <p id="constPodiums"></p>
            </div>
            <div id="totalPoles" class="info-box-ind">
                <h2>Total Poles</h2>
                <p id="constPoles"></p>
            </div>
        </div>
    </div>

</div>

<!-- End -->

<br>

<!-- Driver Comparison Section -->

<div class="subheader">
    <h1>Driver Comparison</h1>
</div>

<div class="comparison_container">

    <br>

    <div class="filter_display">

        <div class="driver1_dropdown">
            <select id="driverSelect1">
                <option value="">Select driver 1</option>
            </select>
        </div>

        <div class="middle_anchor">

            <div id="driver1" class="driver1_name"></div>
            <div class="VS">
                <h2>VS</h2>
            </div>
            <div id="driver2" class="driver2_name"></div>

        </div>

        <div class="driver2_dropdown">
            <select id="driverSelect2">
                <option value="">Select driver 2</option>
            </select>
        </div>

    </div>

    <br>

    <div class="comparison_display">

        <div id="butterflyChart"></div>

    </div>

    <div class="add_chart_section">

        <div class="add_chart_header">

            <div class="add_points_title">
                <h3>Points Scored by Season</h3>
            </div>

            <div class="add_laps_title">
                <h3>Most Fastest Laps by Season</h3>
            </div>

        </div>

        <div class="add_chart_display">

            <div id="points_chart" class="add_points_chart"></div>
            <div id="points_tooltip" style="position: absolute; opacity: 0;"></div>
            <div id="laps_chart" class="add_laps_chart"></div>
            <div id="laps_tooltip" style="position: absolute; opacity: 0;"></div>

        </div>

    </div>

</div>

<!-- End -->

<br><br><br>

<div id="footer">
    <p>2023 | On The Inside | Proudly presented to you by Arif & Shuhail</p>
</div>

<!-- extra -->

<!-- Scripts -->

<!-- Overview Section -->

<!-- Slider & Box Info -->
<script>

    let drivers = {};
    let races = {};

    Papa.parse("assets/data/csv/drivers.csv", {
        header: true,
        download: true,
        complete: function (driversData) {
            drivers = driversData.data.reduce((acc, driver) => {
                acc[driver.driverId] = driver.forename + " " + driver.surname;
                return acc;
            }, {});
        },
    });

    Papa.parse("assets/data/csv/races.csv", {
        header: true,
        download: true,
        complete: function (racesData) {
            races = racesData.data.reduce((acc, race) => {
                acc[race.raceId] = race.year;
                return acc;
            }, {});
        },
    });

    function findDriverWithHighestPointsByYear() {
        const yearSlider = document.getElementById("year");
        const selectedYear = parseInt(yearSlider.value);

        Papa.parse("assets/data/csv/results.csv", {
            header: true,
            download: true,
            complete: function (resultsData) {
                // Getting the sum of points by year for each driver
                function getSumPointsByYear(driverId) {
                    const sumPointsByYear = {};

                    const driverResults = resultsData.data.filter(
                        (result) => result.driverId === driverId
                    );

                    const resultsByYear = driverResults.reduce((acc, result) => {
                        const raceYear = races[result.raceId];
                        if (!acc[raceYear]) {
                            acc[raceYear] = [];
                        }
                        acc[raceYear].push(result);
                        return acc;
                    }, {});

                    Object.entries(resultsByYear).forEach(([year, results]) => {
                        const sumPoints = results.reduce(
                            (sum, result) => sum + parseInt(result.points),
                            0
                        );
                        sumPointsByYear[year] = sumPoints;
                    });

                    return sumPointsByYear;
                }

                let highestPoints = -1;
                let highestPointsDriver = '';

                Object.keys(drivers).forEach((driverId) => {
                    const sumPointsByYear = getSumPointsByYear(driverId);

                    if (sumPointsByYear[selectedYear]) {
                        const points = sumPointsByYear[selectedYear];

                        if (points > highestPoints) {
                            highestPoints = points;
                            highestPointsDriver = drivers[driverId];
                        }
                    }
                });

                const highestPointsDriverElement = document.getElementById("highestPointsDriver");
                highestPointsDriverElement.textContent = highestPointsDriver;
            },
        });
    }

    function findDriverWithMostFastestLapsByYear() {
        const yearSlider = document.getElementById("year");
        const selectedYear = parseInt(yearSlider.value);

        Papa.parse("assets/data/csv/results.csv", {
            header: true,
            download: true,
            complete: function (resultsData) {

                function getCountFastestLapsByYear(driverId) {
                    const countFastestLapsByYear = {};

                    const driverResults = resultsData.data.filter(
                        (result) => result.driverId === driverId && result.rank === "1"
                    );

                    const resultsByYear = driverResults.reduce((acc, result) => {
                        const raceYear = races[result.raceId];
                        if (!acc[raceYear]) {
                            acc[raceYear] = [];
                        }
                        acc[raceYear].push(result);
                        return acc;
                    }, {});

                    Object.entries(resultsByYear).forEach(([year, results]) => {
                        const countFastestLaps = results.length;
                        countFastestLapsByYear[year] = countFastestLaps;
                    });

                    return countFastestLapsByYear;
                }

                let mostFastestLaps = -1;
                let mostFastestLapsDriver = '';

                Object.keys(drivers).forEach((driverId) => {
                    const countFastestLapsByYear = getCountFastestLapsByYear(driverId);

                    if (countFastestLapsByYear[selectedYear]) {
                        const fastestLaps = countFastestLapsByYear[selectedYear];

                        if (fastestLaps > mostFastestLaps) {
                            mostFastestLaps = fastestLaps;
                            mostFastestLapsDriver = drivers[driverId];
                        }
                    }
                });

                const mostFastestLapsElement = document.getElementById("mostFastestLapsDriver");
                mostFastestLapsElement.textContent = mostFastestLapsDriver;
            },
        });
    }

    function findDriverWithMostPodiumFinishesByYear() {
        const yearSlider = document.getElementById("year");
        const selectedYear = parseInt(yearSlider.value);

        Papa.parse("assets/data/csv/results.csv", {
            header: true,
            download: true,
            complete: function (resultsData) {
                function getCountPodiumFinishesByYear(driverId) {
                    const countPodiumFinishesByYear = {};

                    const driverResults = resultsData.data.filter(
                        (result) => result.driverId === driverId && parseInt(result.position) <= 3
                    );

                    const resultsByYear = driverResults.reduce((acc, result) => {
                        const raceYear = races[result.raceId];
                        if (!acc[raceYear]) {
                            acc[raceYear] = [];
                        }
                        acc[raceYear].push(result);
                        return acc;
                    }, {});

                    Object.entries(resultsByYear).forEach(([year, results]) => {
                        const countPodiumFinishes = results.length;
                        countPodiumFinishesByYear[year] = countPodiumFinishes;
                    });

                    return countPodiumFinishesByYear;
                }

                let mostPodiumFinishes = -1;
                let mostPodiumFinishesDriver = '';

                Object.keys(drivers).forEach((driverId) => {
                    const countPodiumFinishesByYear = getCountPodiumFinishesByYear(driverId);

                    if (countPodiumFinishesByYear[selectedYear]) {
                        const podiumFinishes = countPodiumFinishesByYear[selectedYear];

                        if (podiumFinishes > mostPodiumFinishes) {
                            mostPodiumFinishes = podiumFinishes;
                            mostPodiumFinishesDriver = drivers[driverId];
                        }
                    }
                });


                const mostPodiumFinishesElement = document.getElementById("mostPodiumFinishesDriver");
                mostPodiumFinishesElement.textContent = mostPodiumFinishesDriver;
            },
        });
    }
    function findConstructorWithHighestPointsByYear() {
        const yearSlider = document.getElementById("year");
        const selectedYear = parseInt(yearSlider.value);

        Papa.parse("assets/data/csv/constructors.csv", {
            header: true,
            download: true,
            complete: function (constructorsData) {
                const constructors = constructorsData.data.reduce((acc, constructor) => {
                    acc[constructor.constructorId] = constructor.name;
                    return acc;
                }, {});

                Papa.parse("assets/data/csv/results.csv", {
                    header: true,
                    download: true,
                    complete: function (resultsData) {
                        function getSumPointsByYear(constructorId) {
                            const sumPointsByYear = {};

                            const constructorResults = resultsData.data.filter(
                                (result) => result.constructorId === constructorId
                            );

                            const resultsByYear = constructorResults.reduce((acc, result) => {
                                const raceYear = races[result.raceId];
                                if (!acc[raceYear]) {
                                    acc[raceYear] = [];
                                }
                                acc[raceYear].push(result);
                                return acc;
                            }, {});

                            Object.entries(resultsByYear).forEach(([year, results]) => {
                                const sumPoints = results.reduce(
                                    (sum, result) => sum + parseInt(result.points),
                                    0
                                );
                                sumPointsByYear[year] = sumPoints;
                            });

                            return sumPointsByYear;
                        }

                        let highestPoints = -1;
                        let highestPointsConstructor = '';

                        Object.keys(constructors).forEach((constructorId) => {
                            const sumPointsByYear = getSumPointsByYear(constructorId);

                            if (sumPointsByYear[selectedYear]) {
                                const points = sumPointsByYear[selectedYear];

                                if (points > highestPoints) {
                                    highestPoints = points;
                                    highestPointsConstructor = constructors[constructorId];
                                }
                            }
                        });

                        const constructorChampionElement = document.getElementById("highestPointsConstructor");
                        constructorChampionElement.textContent = highestPointsConstructor;
                    },
                });
            },
        });
    }

    const yearSlider = document.getElementById("year");
    const prevYearButton = document.getElementById("prevYear");
    const nextYearButton = document.getElementById("nextYear");
    const selectedYearDisplay = document.getElementById("selectedYearDisplay");

    // Update the selected year display
    function updateSelectedYearDisplay() {
        const selectedYear = parseInt(yearSlider.value);
        selectedYearDisplay.textContent = `Year: ${selectedYear}`;
    }

    yearSlider.addEventListener("input", function () {
        findDriverWithHighestPointsByYear();
        findDriverWithMostFastestLapsByYear();
        findDriverWithMostPodiumFinishesByYear();
        findConstructorWithHighestPointsByYear();
        updateChart();
        updateSelectedYearDisplay();
    });

    prevYearButton.addEventListener("click", function () {
        yearSlider.stepDown();
        findDriverWithHighestPointsByYear();
        findDriverWithMostFastestLapsByYear();
        findDriverWithMostPodiumFinishesByYear();
        findConstructorWithHighestPointsByYear();
        updateChart();
        updateSelectedYearDisplay();
    });

    nextYearButton.addEventListener("click", function () {
        yearSlider.stepUp();
        findDriverWithHighestPointsByYear();
        findDriverWithMostFastestLapsByYear();
        findDriverWithMostPodiumFinishesByYear();
        findConstructorWithHighestPointsByYear();
        updateChart();
        updateSelectedYearDisplay();
    });

    findDriverWithHighestPointsByYear();
    findDriverWithMostFastestLapsByYear();
    findDriverWithMostPodiumFinishesByYear();
    findConstructorWithHighestPointsByYear();
    updateChart();
    updateSelectedYearDisplay();
</script>

<!-- Driver Standings Chart -->
<script>
    let racesData, driversData, circuitsData, resultsData;
    let svg;

    const updateChart = () => {

        d3.select("#chart").selectAll("svg").remove();

        // Filter the data for a specific year
        const selectedYear = yearSlider.value;
        const filteredRacesData = racesData.filter(race => race.year === selectedYear);

        const circuitNames = filteredRacesData.map(race => {
            const circuitId = race.circuitId;
            const circuit = circuitsData.find(circuit => circuit.circuitId === circuitId);
            return circuit.name;
        });

        const driverPointsByCircuit = {};
        resultsData.forEach(result => {
            const raceId = result.raceId;
            const driverId = result.driverId;
            const points = +result.points;

            if (filteredRacesData.some(race => race.raceId === raceId)) {
                if (!driverPointsByCircuit[driverId]) {
                    driverPointsByCircuit[driverId] = Array(circuitNames.length).fill(0);
                }

                const circuitIndex = filteredRacesData.findIndex(race => race.raceId === raceId);
                driverPointsByCircuit[driverId][circuitIndex] += points;
            }
        });

        Object.values(driverPointsByCircuit).forEach(points => {
            for (let i = 1; i < points.length; i++) {
                points[i] += points[i - 1];
            }
        });

        const driverData = Object.entries(driverPointsByCircuit).map(([driverId, points]) => {
            const driver = driversData.find(driver => driver.driverId === driverId);
            const driverName = `${driver.forename} ${driver.surname}`;
            return { driver: driverName, points };
        });

        const margin = { top: 50, right: 20, bottom: 30, left: 50 };
        const width = 1200 - margin.left - margin.right;
        const height = 550 - margin.top - margin.bottom;

        svg = d3.select("#chart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        const xScale = d3.scalePoint()
            .domain(circuitNames)
            .range([0, width])
            .padding(0.5);

        const yScale = d3.scaleLinear()
            .domain([0, d3.max(driverData, d => d3.max(d.points))])
            .range([height, 0]);

        const line = d3.line()
            .x((d, i) => xScale(circuitNames[i]))
            .y(d => yScale(d));

        svg.selectAll(".line")
            .data(driverData)
            .enter()
            .append("path")
            .attr("class", "line")
            .attr("d", d => line(d.points))
            .style("fill", "none")
            .style("stroke", (d, i) => d3.schemeCategory10[i % 10])
            .each(function () {
                const path = d3.select(this);
                const totalLength = path.node().getTotalLength();

                path.attr("stroke-dasharray", totalLength + " " + totalLength)
                    .attr("stroke-dashoffset", totalLength)
                    .transition()
                    .duration(2000)
                    .attr("stroke-dashoffset", 0);
            })
            .on("mouseover", (event, d) => {
                d3.select(event.target)
                    .style("stroke-width", "4px");

                svg.append("text")
                    .attr("class", "driver-name")
                    .attr("x", xScale(circuitNames[circuitNames.length - 5]) )
                    .attr("y", yScale(d.points[d.points.length - 1]) - 10)
                    .text(d.driver);

                svg.append("text")
                    .attr("class", "points-scored")
                    .attr("x", xScale(circuitNames[circuitNames.length - 5]))
                    .attr("y", yScale(d.points[d.points.length - 1]) + 10)
                    .text(d.points[d.points.length - 1]);
            })
            .on("mouseout", (event, d) => {
                d3.select(event.target)
                    .style("stroke-width", "2px");
                svg.select(".driver-name").remove();
                svg.select(".points-scored").remove();
            });

        // X-axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(d3.scaleBand().domain([...Array(circuitNames.length).keys()].map(d => d + 1)).range([1, width])));

        // Y-axis
        svg.append("g")
            .call(d3.axisLeft(yScale));

        // X-axis label
        svg.append("text")
            .attr("class", "axis-label")
            .attr("x", width / 2)
            .attr("y", height + margin.top - 20)
            .attr("text-anchor", "middle")
            .text("Circuit");

        // Y-axis label
        svg.append("text")
            .attr("class", "axis-label")
            .attr("x", -height / 2)
            .attr("y", -margin.left + 13)
            .attr("text-anchor", "middle")
            .attr("transform", "rotate(-90)")
            .text("Points");

        // Chart Title
        svg.append("text")
            .attr("x", width / 2)
            .attr("y", 50)
            .attr("text-anchor", "middle")
            .style("font-size", "16px")

    };
    Promise.all([
        d3.csv('assets/data/csv/drivers.csv'),
        d3.csv('assets/data/csv/races.csv'),
        d3.csv('assets/data/csv/circuits.csv'),
        d3.csv('assets/data/csv/results.csv')
    ]).then(([drivers, races, circuits, results]) => {
        driversData = drivers;
        racesData = races;
        circuitsData = circuits;
        resultsData = results;

        yearSlider.addEventListener("input", updateChart);

        updateChart();
        updateSelectedYearDisplay();
    }).catch(error => {
        console.log(error);
    });
</script>

<!-- End -->

<!-- Map Section -->

<script>

    let csvData = {};

    const driverSelect = document.getElementById("driverSelect");
    const mapViewSelect = document.getElementById("mapViewSelect");

    // FOR DRIVER COMPARISON //
    const driverSelect1 = document.getElementById("driverSelect1");
    const driverSelect2 = document.getElementById("driverSelect2");

    let mapView = 1;
    let selectedDriver = 0;

    // Read and parse multiple CSV files
    const files = ["assets/data/csv/drivers.csv", "assets/data/csv/circuits.csv", "assets/data/csv/constructor_results.csv",
        "assets/data/csv/constructor_standings.csv", "assets/data/csv/constructors.csv", "assets/data/csv/driver_standings.csv",
        "assets/data/csv/lap_times.csv", "assets/data/csv/pit_stops.csv", "assets/data/csv/qualifying.csv",
        "assets/data/csv/races.csv", "assets/data/csv/results.csv", "assets/data/csv/sprint_results.csv"];

    files.forEach(function(file) {
        const filename = file.split('/').pop();
        fetch(file)
            .then(response => response.text())
            .then(csvContent => {
                Papa.parse(csvContent, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        // Handle the parsed data for each file
                        csvData[filename] = results.data;
                        if (filename === "drivers.csv") {
                            populateDriverDropdown();
                            populateMapDriverDropdown();
                        }
                    },
                    error: function(error) {
                        console.error("Error parsing file:", file);
                        console.error(error);
                    }
                });
            })
            .catch(error => {
                console.error("Error loading CSV file:", file);
                console.error(error);
            });
    });

    // Add option elements to the driver dropdowns
    function populateMapDriverDropdown() {
        const driverData = csvData["drivers.csv"];

        driverData.sort(function(a, b) {
            const nameA = a.forename.charAt(0).toUpperCase();
            const nameB = b.forename.charAt(0).toUpperCase();
            if (nameA < nameB) {
                return -1;
            }
            if (nameA > nameB) {
                return 1;
            }
            return 0;
        });

        driverData.forEach(function(driver) {
            const option = document.createElement("option");
            option.value = driver.driverId;
            option.text = driver.forename + " " + driver.surname;

            driverSelect.appendChild(option);
        });
    }

    // FOR DRIVER COMPARISON //
    function populateDriverDropdown() {
        const driverData = csvData["drivers.csv"];

        driverData.sort(function(a, b) {
            const nameA = a.forename.toUpperCase();
            const nameB = b.forename.toUpperCase();
            if (nameA < nameB) {
                return -1;
            }
            if (nameA > nameB) {
                return 1;
            }
            return 0;
        });

        driverData.forEach(function(driver) {
            const option1 = document.createElement("option");
            const option2 = document.createElement("option");
            option1.value = driver.driverId;
            option1.text = driver.forename + " " + driver.surname;
            option2.value = driver.driverId;
            option2.text = driver.forename + " " + driver.surname;
            driverSelect1.appendChild(option1);
            driverSelect2.appendChild(option2);
        });
    }

    const init_width = 1250;
    const init_height = 750;

    const init_svg = d3.select("#map")
        .append("svg")
        .attr("width", init_width)
        .attr("height", init_height);

    const init_projection = d3.geoMercator()
        .scale(180)
        .translate([init_width / 2, init_height / 1.4]);

    const init_path = d3.geoPath().projection(init_projection);
    const init_tooltip = d3.select("#tooltip");

    d3.json("assets/data/countries.geojson").then(function(mapData) {
        init_svg.selectAll("path")
            .data(mapData.features)
            .enter()
            .append("path")
            .attr("d", init_path)
            .attr("fill", "#ccc")
            .on("mouseover", function(event, d) {
                d3.select(this).style("opacity", 0.7);
                init_tooltip.style("left", event.pageX + "px")
                    .style("top", event.pageY + "px")
                    .style("opacity", 1)
                    .html(`<strong>${d.properties.ADMIN}</strong>`);
            })
            .on("mouseout", function() {
                d3.select(this).style("opacity", 1);
                init_tooltip.style("opacity", 0);
            });
    });

    const init_zoom = d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", zoomed);

    init_svg.call(init_zoom);

    function zoomed(event) {
        const { transform } = event;
        init_svg.selectAll("path")
            .attr("transform", transform);
    }

    init_svg.on("wheel", function(event) {
        event.preventDefault();

        const currentScale = d3.zoomTransform(this).k;

        const newScale = currentScale - event.deltaY * 0.01;

        init_svg.transition().duration(200).call(init_zoom.scaleTo, newScale);
    });

    function updateMap(map, driverId, chartContainerId) {

        const driverData = csvData["drivers.csv"];
        const driverResultsData = csvData["results.csv"];
        const raceData = csvData["races.csv"];
        const circuitData = csvData["circuits.csv"];
        const qualifyingData = csvData["qualifying.csv"];

        if (driverId !== 0) {
            const driver = driverData.find(function (driver) {
                return driver.driverId === driverId;
            });

            const driverName = driver.forename + " " + driver.surname;
        }

        // Wins
        const driverWinData = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        })
        const winRaceIds = driverWinData.map(function (result) {
            return result.raceId;
        });
        const winRaces = raceData.filter(function (result) {
            return winRaceIds.includes(result.raceId);
        });
        const winCircuitIds = winRaces.map(function (result) {
            return result.circuitId;
        });
        const winCircuits = circuitData.filter(function (result) {
            return winCircuitIds.includes(result.circuitId);
        });

        const countryWins = {};
        winRaces.forEach(function (race) {
            const circuit = winCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryWins[country]) {
                    countryWins[country]++;
                } else {
                    countryWins[country] = 1;
                }
            }
        });

        // Podiums
        const driverPodiumData = driverResultsData.filter(function (result) {
            return result.driverId === driverId && result.position <= 3;
        });
        const podiumRaceIds = driverPodiumData.map(function (result) {
            return result.raceId;
        });
        const podiumRaces = raceData.filter(function (result) {
            return podiumRaceIds.includes(result.raceId);
        });
        const podiumCircuitIds = podiumRaces.map(function (result) {
            return result.circuitId;
        });
        const podiumCircuits = circuitData.filter(function (result) {
            return podiumCircuitIds.includes(result.circuitId);
        });

        const countryPodiums = {};
        podiumRaces.forEach(function (race) {
            const circuit = podiumCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryPodiums[country]) {
                    countryPodiums[country]++;
                } else {
                    countryPodiums[country] = 1;
                }
            }
        });

        // Poles
        const driverPoleData = qualifyingData.filter(function (result) {
            return result.driverId === driverId && result.position === 1;
        });
        const poleRaceIds = driverPoleData.map(function (result) {
            return result.raceId;
        });
        const poleRaces = raceData.filter(function (result) {
            return poleRaceIds.includes(result.raceId);
        });
        const poleCircuitIds = poleRaces.map(function (result) {
            return result.circuitId;
        });
        const poleCircuits = circuitData.filter(function (result) {
            return poleCircuitIds.includes(result.circuitId);
        });

        const countryPoles = {};
        poleRaces.forEach(function (race) {
            const circuit = poleCircuits.find(function (circuit) {
                return circuit.circuitId === race.circuitId;
            });

            if (circuit) {
                const country = circuit.country;
                if (countryPoles[country]) {
                    countryPoles[country]++;
                } else {
                    countryPoles[country] = 1;
                }
            }
        });

        // Max values for scaling
        const maxWins = Math.max(...Object.values(countryWins));
        const maxPodiums = Math.max(...Object.values(countryPodiums));
        const maxPoles = Math.max(...Object.values(countryPoles));

        if (map === 1) {

            const chartContainer = document.getElementById(chartContainerId);
            chartContainer.innerHTML = "";

            const width = 1250;
            const height = 750;

            const svg = d3.select("#" + chartContainerId)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const projection = d3.geoMercator()
                .scale(180)
                .translate([width / 2, height / 1.4]);

            const path = d3.geoPath().projection(projection);
            const tooltip = d3.select("#tooltip");

            d3.json("assets/data/countries.geojson").then(function(mapData) {

                svg.selectAll("path")
                    .data(mapData.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", function(d) {
                        const wins = countryWins[d.properties.ADMIN];
                        if (wins) {
                            return d3.interpolateReds(wins / maxWins);
                        } else {
                            return "#ccc";
                        }
                    })
                    .on("mouseover", function(event, d) {
                        d3.select(this).style("opacity", 0.7);

                        const wins = countryWins[d.properties.ADMIN];
                        const winsText = wins !== null && wins !== undefined ? wins : 0;

                        tooltip.style("left", event.pageX + "px")
                            .style("top", event.pageY + "px")
                            .style("opacity", 1)
                            .html(`<strong>${d.properties.ADMIN}</strong><br>Wins: ${winsText}`);
                    })
                    .on("mouseout", function() {
                        d3.select(this).style("opacity", 1);
                        tooltip.style("opacity", 0);
                    });
            });

            const zoom = d3.zoom()
                .scaleExtent([1, 8])
                .on("zoom", zoomed);

            svg.call(zoom);

            function zoomed(event) {
                const { transform } = event;
                svg.selectAll("path")
                    .attr("transform", transform);
            }

            svg.on("wheel", function(event) {
                event.preventDefault();

                const currentScale = d3.zoomTransform(this).k;

                const newScale = currentScale - event.deltaY * 0.01;

                svg.transition().duration(200).call(zoom.scaleTo, newScale);
            });

        } else if (map === 2) {

            const chartContainer = document.getElementById(chartContainerId);
            chartContainer.innerHTML = "";

            const width = 1250;
            const height = 750;

            const svg = d3.select("#" + chartContainerId)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const projection = d3.geoMercator()
                .scale(180)
                .translate([width / 2, height / 1.4]);

            const path = d3.geoPath().projection(projection);
            const tooltip = d3.select("#tooltip");

            d3.json("assets/data/countries.geojson").then(function(mapData) {
                svg.selectAll("path")
                    .data(mapData.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", function(d) {
                        const podiums = countryPodiums[d.properties.ADMIN];
                        if (podiums) {
                            return d3.interpolateGreens(podiums / maxPodiums);
                        } else {
                            return "#ccc";
                        }
                    })
                    .on("mouseover", function(event, d) {
                        d3.select(this).style("opacity", 0.7);

                        const podiums = countryPodiums[d.properties.ADMIN];
                        const podiumsText = podiums !== null && podiums !== undefined ? podiums : 0;

                        tooltip.style("left", event.pageX + "px")
                            .style("top", event.pageY + "px")
                            .style("opacity", 1)
                            .html(`<strong>${d.properties.ADMIN}</strong><br>Podiums: ${podiumsText}`);
                    })
                    .on("mouseout", function() {
                        d3.select(this).style("opacity", 1);
                        tooltip.style("opacity", 0);
                    });
            });

            const zoom = d3.zoom()
                .scaleExtent([1, 8])
                .on("zoom", zoomed);

            svg.call(zoom);

            function zoomed(event) {
                const { transform } = event;

                svg.selectAll("path")
                    .attr("transform", transform);
            }

            svg.on("wheel", function(event) {
                event.preventDefault();
                const currentScale = d3.zoomTransform(this).k;
                const newScale = currentScale - event.deltaY * 0.01;
                svg.transition().duration(200).call(zoom.scaleTo, newScale);
            });

        } else if (map === 3) {

            const chartContainer = document.getElementById(chartContainerId);
            chartContainer.innerHTML = "";

            const width = 1250;
            const height = 750;

            const svg = d3.select("#" + chartContainerId)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const projection = d3.geoMercator()
                .scale(180)
                .translate([width / 2, height / 1.4]);

            const path = d3.geoPath().projection(projection);
            const tooltip = d3.select("#tooltip");

            d3.json("assets/data/countries.geojson").then(function(mapData) {
                svg.selectAll("path")
                    .data(mapData.features)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", function(d) {
                        const poles = countryPoles[d.properties.ADMIN];
                        if (poles) {
                            return d3.interpolateBlues(poles / maxPoles);
                        } else {
                            return "#ccc";
                        }
                    })
                    .on("mouseover", function(event, d) {
                        d3.select(this).style("opacity", 0.7);

                        const poles = countryPoles[d.properties.ADMIN];
                        const polesText = poles !== null && poles !== undefined ? poles : 0;

                        tooltip.style("left", event.pageX + "px")
                            .style("top", event.pageY + "px")
                            .style("opacity", 1)
                            .html(`<strong>${d.properties.ADMIN}</strong><br>Poles: ${polesText}`);
                    })
                    .on("mouseout", function() {
                        d3.select(this).style("opacity", 1);
                        tooltip.style("opacity", 0);
                    });
            });

            const zoom = d3.zoom()
                .scaleExtent([1, 8])
                .on("zoom", zoomed);

            svg.call(zoom);

            function zoomed(event) {
                const { transform } = event;
                svg.selectAll("path")
                    .attr("transform", transform);
            }

            svg.on("wheel", function(event) {
                event.preventDefault();
                const currentScale = d3.zoomTransform(this).k;
                const newScale = currentScale - event.deltaY * 0.01;
                svg.transition().duration(200).call(zoom.scaleTo, newScale);
            });

        }

    }

    mapViewSelect.addEventListener("change", function() {
        const map = mapViewSelect.value;

        if (map) {
            if (selectedDriver === 0) {
                mapView = parseInt(map);
                updateMap(0, selectedDriver, "map");
            } else {
                mapView = parseInt(map);
                updateMap(mapView, selectedDriver, "map");
            }
        }
    });

    driverSelect.addEventListener("change", function () {
        const driver = driverSelect.value;

        if (driver) {
            selectedDriver = parseInt(driver);
            updateMap(mapView, selectedDriver, "map");
        }
    });

</script>

<!-- End -->

<!-- Constructor Section -->

<script>

    const totalPointsDisplay = document.getElementById("constPoints");
    const totalWinsDisplay = document.getElementById("constWins");
    const totalPodiumsDisplay = document.getElementById("constPodiums");
    const totalPolesDisplay = document.getElementById("constPoles");

    // Update the constructor info display
    function updateConstructorInfoDisplay(points, wins, podiums, poles) {
        totalPointsDisplay.textContent = `${points}`;
        totalWinsDisplay.textContent = `${wins}`;
        totalPodiumsDisplay.textContent = `${podiums}`;
        totalPolesDisplay.textContent = `${poles}`;

        if (points === -1 && wins === -1 && podiums === -1 && poles === -1) {
            totalPointsDisplay.textContent = ``;
            totalWinsDisplay.textContent = ``;
            totalPodiumsDisplay.textContent = ``;
            totalPolesDisplay.textContent = ``;
        }
    }

    function updateWordCloud() {

        const qualifyingData = csvData["qualifying.csv"];
        const constructorData = csvData["constructors.csv"];
        const constructorStandingsData = csvData["constructor_standings.csv"];

        const pointsData = {};
        const winData = {};
        const podiumData = {};
        const poleData = {};

        constructorStandingsData.forEach(function(d) {
            const constructor = constructorData.find(constructor => constructor.constructorId === d.constructorId);

            if (constructor !== undefined && constructor !== null) {
                const constructorName = constructor.name;
                const points = +d.points;

                if (pointsData.hasOwnProperty(constructorName)) {
                    pointsData[constructorName] += points;
                } else {
                    pointsData[constructorName] = points;
                }
            }

        });

        const constructorsWordCloudData = Object.entries(pointsData).map(([constructorName, points]) => {
            return { word: constructorName, size: parseFloat(points).toString() };
        });

        const constructorWinData = constructorStandingsData.filter(function (result) {
            return result.position === 1;
        })

        constructorWinData.forEach(function(d) {
            const constructor = constructorData.find(constructor => constructor.constructorId === d.constructorId);

            if (constructor !== undefined && constructor !== null) {
                const constructorName = constructor.name;

                if (winData.hasOwnProperty(constructorName)) {
                    winData[constructorName]++;
                } else {
                    winData[constructorName] = 1;
                }
            }

        });

        const constructorPodiumData = constructorStandingsData.filter(function (result) {
            return result.position <= 3;
        });

        constructorPodiumData.forEach(function(d) {
            const constructor = constructorData.find(constructor => constructor.constructorId === d.constructorId);

            if (constructor !== undefined && constructor !== null) {
                const constructorName = constructor.name;

                if (podiumData.hasOwnProperty(constructorName)) {
                    podiumData[constructorName]++;
                } else {
                    podiumData[constructorName] = 1;
                }
            }

        });

        const constructorPoleData = qualifyingData.filter(function (result) {
            return result.position === 1;
        });

        constructorPoleData.forEach(function(d) {
            const constructor = constructorData.find(constructor => constructor.constructorId === d.constructorId);

            if (constructor !== undefined && constructor !== null) {
                const constructorName = constructor.name;

                if (poleData.hasOwnProperty(constructor.name)) {
                    poleData[constructorName]++;
                } else {
                    poleData[constructorName] = 1;
                }
            }

        });

        const inputRange = [0, d3.max(constructorsWordCloudData, d => d.size)];
        const outputRange = [15, 150];

        const sizeScale = d3.scaleLinear()
            .domain(inputRange)
            .range(outputRange);

        const margin = {top: 10, right: 10, bottom: 10, left: 10},
            width = 1000 - margin.left - margin.right,
            height = 750 - margin.top - margin.bottom;

        const svg = d3.select("#wordCloudChart").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        const layout = d3.layout.cloud()
            .size([width, height])
            .words(constructorsWordCloudData.map(function(d) {
                return {text: d.word, size:d.size}; }))
            .padding(5)
            .rotate(function() { return ~~(Math.random() * 2) * 90; })
            .fontSize(function(d) { return sizeScale(d.size); })
            .on("end", draw);
        layout.start();

        function draw(words) {
            const tooltip = d3
                .select("#tooltip_word")
                .style("background-color", "white")
                .style("border", "1px solid black")
                .style("padding", "5px")
                .style("opacity", 0);

            svg
                .append("g")
                .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
                .selectAll("text")
                .data(words)
                .enter()
                .append("text")
                .style("font-size", function(d) { return d.size; })
                .style("fill", function (d, i) {
                    if (i < 5) {
                        return "red";
                    } else {
                        return "#377eb8";
                    }
                })
                .style("text-shadow", function (d, i) {
                    if (i < 5) {
                        return "2px 2px 4px rgba(0, 0, 0, 0.3)";
                    } else {
                        return "none";
                    }
                })
                .attr("text-anchor", "middle")
                .style("font-family", "Impact")
                .attr("transform", function(d) {
                    return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
                })
                .text(function(d) { return d.text; })
                .on("click", function(event, d) {
                    d3.select(this).style("opacity", 0.5);
                    const points = pointsData[d.text] ?? 0;
                    const wins = winData[d.text] ?? 0;
                    const podiums = podiumData[d.text] ?? 0;
                    const poles = poleData[d.text] ?? 0;

                    updateConstructorInfoDisplay(points, wins, podiums, poles);

                })
                .on("mouseover", function() {
                    d3.select(this).style("cursor", "pointer");
                })
                .on("mouseout", function() {
                    d3.select(this).style("cursor", "default");
                    d3.select(this).style("opacity", 1);
                    updateConstructorInfoDisplay(-1, -1, -1, -1);
                });
        }

    }

    setTimeout(function() {
        updateWordCloud("con_chart");
    }, 2500);

</script>

<!-- End -->

<!-- Driver Comparison Section -->

<script>

    const driver1Display = document.getElementById("driver1");
    const driver2Display = document.getElementById("driver2");

    function updateDriver1Display(selectedDriver) {
        driver1Display.textContent = `${selectedDriver}`;
    }

    function updateDriver2Display(selectedDriver) {
        driver2Display.textContent = `${selectedDriver}`;
    }

    function initButterflyChart(driver1Name, driver2Name, driverId1, driverId2) {

        updateDriver1Display(driver1Name);
        updateDriver2Display(driver2Name);

        const driverResultsData = csvData["results.csv"];
        const qualifyingData = csvData["qualifying.csv"];

        const driver1Results = driverResultsData.filter(function (result) {
            return result.driverId === driverId1;
        });

        const driver2Results = driverResultsData.filter(function (result) {
            return result.driverId === driverId2;
        });

        const driver1RaceCount = driver1Results.length;
        const driver2RaceCount = driver2Results.length;

        const driver1Wins = driverResultsData.filter(function (result) {
            return result.driverId === driverId1 && result.position === 1;
        }).length;

        const driver2Wins = driverResultsData.filter(function (result) {
            return result.driverId === driverId2 && result.position === 1;
        }).length;

        const driver1Podiums = driverResultsData.filter(function (result) {
            return result.driverId === driverId1 && result.position <= 3;
        }).length;

        const driver2Podiums = driverResultsData.filter(function (result) {
            return result.driverId === driverId2 && result.position <= 3;
        }).length;

        const driver1Poles = qualifyingData.filter(function (result) {
            return result.driverId === driverId1 && result.position === 1;
        }).length;

        const driver2Poles = qualifyingData.filter(function (result) {
            return result.driverId === driverId2 && result.position === 1;
        }).length;

        const maxRaceCount = Math.max(driver1RaceCount, driver2RaceCount);
        const barWidthScale = d3.scaleLinear()
            .domain([0, maxRaceCount])
            .range([0, 600]);

        const svg = d3.select("#butterflyChart")
            .append("svg")
            .attr("width", 1460)
            .attr("height", 300);

        // Driver 1 bar
        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1RaceCount))
            .attr("y", 25)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1RaceCount));

        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1Wins))
            .attr("y", 80)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Wins));

        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1Podiums))
            .attr("y", 135)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Podiums));

        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1Poles))
            .attr("y", 190)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Poles));

        // Driver 2 bar
        svg.append("rect")
            .attr("x", 800)
            .attr("y", 25)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2RaceCount));

        svg.append("rect")
            .attr("x", 800)
            .attr("y", 80)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Wins));

        svg.append("rect")
            .attr("x", 800)
            .attr("y", 135)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Podiums));

        svg.append("rect")
            .attr("x", 800)
            .attr("y", 190)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Poles));

        // Driver 1 text
        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1RaceCount) - 25)
            .attr("y", 70)
            .attr("text-anchor", "middle")
            .text(driver1RaceCount)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1Wins) - 25)
            .attr("y", 125)
            .attr("text-anchor", "middle")
            .text(driver1Wins)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1Podiums) - 25)
            .attr("y", 175)
            .attr("text-anchor", "middle")
            .text(driver1Podiums)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1Poles) - 25)
            .attr("y", 235)
            .attr("text-anchor", "middle")
            .text(driver1Poles)
            .style("fill", "#000");

        // Driver 2 text
        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2RaceCount) + 25)
            .attr("y", 70)
            .attr("text-anchor", "middle")
            .text(driver2RaceCount)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2Wins) + 25)
            .attr("y", 125)
            .attr("text-anchor", "middle")
            .text(driver2Wins)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2Podiums) + 25)
            .attr("y", 175)
            .attr("text-anchor", "middle")
            .text(driver2Podiums)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2Poles) + 25)
            .attr("y", 235)
            .attr("text-anchor", "middle")
            .text(driver2Poles)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 725)
            .attr("y", 60)
            .attr("text-anchor", "middle")
            .text("Races")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 725)
            .attr("y", 110)
            .attr("text-anchor", "middle")
            .text("Wins")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 725)
            .attr("y", 170)
            .attr("text-anchor", "middle")
            .text("Podiums")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 725)
            .attr("y", 230)
            .attr("text-anchor", "middle")
            .text("Poles")
            .style("fill", "#000");

    }

    setTimeout(function() {
        const driverData = csvData["drivers.csv"];

        const driverId1 = 1;
        const driverId2 = 830;

        const driver1 = driverData.find(function (driver) {
            return driver.driverId === driverId1;
        });

        const driver2 = driverData.find(function (driver) {
            return driver.driverId === driverId2;
        });

        const driver1Name = driver1.forename + " " + driver1.surname;
        const driver2Name = driver2.forename + " " + driver2.surname;

        initButterflyChart(driver1Name, driver2Name, driverId1, driverId2);

    }, 2000);

    // Function to update the butterfly chart
    function updateButterflyChart(driverId1, driverId2, chartContainerId) {

        const driverResultsData = csvData["results.csv"];
        const qualifyingData = csvData["qualifying.csv"];

        const driver1Results = driverResultsData.filter(function (result) {
            return result.driverId === driverId1;
        });

        const driver2Results = driverResultsData.filter(function (result) {
            return result.driverId === driverId2;
        });

        const driver1RaceCount = driver1Results.length;
        const driver2RaceCount = driver2Results.length;

        const driver1Wins = driverResultsData.filter(function (result) {
            return result.driverId === driverId1 && result.position === 1;
        }).length;

        const driver2Wins = driverResultsData.filter(function (result) {
            return result.driverId === driverId2 && result.position === 1;
        }).length;

        const driver1Podiums = driverResultsData.filter(function (result) {
            return result.driverId === driverId1 && result.position <= 3;
        }).length;

        const driver2Podiums = driverResultsData.filter(function (result) {
            return result.driverId === driverId2 && result.position <= 3;
        }).length;

        const driver1Poles = qualifyingData.filter(function (result) {
            return result.driverId === driverId1 && result.position === 1;
        }).length;

        const driver2Poles = qualifyingData.filter(function (result) {
            return result.driverId === driverId2 && result.position === 1;
        }).length;

        const maxRaceCount = Math.max(driver1RaceCount, driver2RaceCount);
        const barWidthScale = d3.scaleLinear()
            .domain([0, maxRaceCount])
            .range([0, 600]);

        const svgContainer = d3.select("#butterflyChart");

        svgContainer.selectAll("*").remove();

        const svg = d3.select("#butterflyChart")
            .append("svg")
            .attr("width", 1460)
            .attr("height", 300);

        // Driver 1 bar
        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1RaceCount))
            .attr("y", 25)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1RaceCount));

        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1Wins))
            .attr("y", 80)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Wins));

        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1Podiums))
            .attr("y", 135)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Podiums));

        svg.append("rect")
            .attr("x", 650 - barWidthScale(driver1Poles))
            .attr("y", 190)
            .attr("height", 50)
            .attr("fill", "#377eb8")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver1Poles));

        // Driver 2 bar
        svg.append("rect")
            .attr("x", 800)
            .attr("y", 25)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2RaceCount));

        svg.append("rect")
            .attr("x", 800)
            .attr("y", 80)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Wins));

        svg.append("rect")
            .attr("x", 800)
            .attr("y", 135)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Podiums));

        svg.append("rect")
            .attr("x", 800)
            .attr("y", 190)
            .attr("height", 50)
            .attr("fill", "#e41a1c")
            .transition()
            .duration(1000)
            .attr("width", barWidthScale(driver2Poles));

        // Driver 1 text
        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1RaceCount) - 25)
            .attr("y", 70)
            .attr("text-anchor", "middle")
            .text(driver1RaceCount)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1Wins) - 25)
            .attr("y", 125)
            .attr("text-anchor", "middle")
            .text(driver1Wins)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1Podiums) - 25)
            .attr("y", 175)
            .attr("text-anchor", "middle")
            .text(driver1Podiums)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 650 - barWidthScale(driver1Poles) - 25)
            .attr("y", 235)
            .attr("text-anchor", "middle")
            .text(driver1Poles)
            .style("fill", "#000");

        // Driver 2 text
        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2RaceCount) + 25)
            .attr("y", 70)
            .attr("text-anchor", "middle")
            .text(driver2RaceCount)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2Wins) + 25)
            .attr("y", 125)
            .attr("text-anchor", "middle")
            .text(driver2Wins)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2Podiums) + 25)
            .attr("y", 175)
            .attr("text-anchor", "middle")
            .text(driver2Podiums)
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 800 + barWidthScale(driver2Poles) + 25)
            .attr("y", 235)
            .attr("text-anchor", "middle")
            .text(driver2Poles)
            .style("fill", "#000"); /*gg*/

        svg.append("text")
            .attr("x", 725)
            .attr("y", 60)
            .attr("text-anchor", "middle")
            .text("Races")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 725)
            .attr("y", 110)
            .attr("text-anchor", "middle")
            .text("Wins")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 725)
            .attr("y", 170)
            .attr("text-anchor", "middle")
            .text("Podiums")
            .style("fill", "#000");

        svg.append("text")
            .attr("x", 725)
            .attr("y", 230)
            .attr("text-anchor", "middle")
            .text("Poles")
            .style("fill", "#000");
    }

    driverSelect1.addEventListener("change", function () {
        const driverData = csvData["drivers.csv"];

        const selectedDriver1 = driverSelect1.value;
        const selectedDriver2 = driverSelect2.value;

        const driver1 = driverData.find(function (driver) {
            return driver.driverId === parseInt(selectedDriver1);
        });

        const driver1Name = driver1.forename + " " + driver1.surname;

        updateDriver1Display(driver1Name);

        if (selectedDriver1 && selectedDriver2) {
            const desiredDriverId1 = parseInt(selectedDriver1);
            const desiredDriverId2 = parseInt(selectedDriver2);

            updateButterflyChart(desiredDriverId1, desiredDriverId2, "butterflyChart");
        }
    });

    driverSelect2.addEventListener("change", function () {
        const driverData = csvData["drivers.csv"];

        const selectedDriver1 = driverSelect1.value;
        const selectedDriver2 = driverSelect2.value;

        const driver2 = driverData.find(function (driver) {
            return driver.driverId === parseInt(selectedDriver2);
        });

        const driver2Name = driver2.forename + " " + driver2.surname;

        updateDriver2Display(driver2Name);

        if (selectedDriver1 && selectedDriver2) {
            const desiredDriverId1 = parseInt(selectedDriver1);
            const desiredDriverId2 = parseInt(selectedDriver2);

            updateButterflyChart(desiredDriverId1, desiredDriverId2, "butterflyChart");
        }
    });

</script>

<!-- Points Scored by Season -->
<script>

    Papa.parse("assets/data/csv/drivers.csv", {
        header: true,
        download: true,
        complete: function (driversData) {
            const drivers = driversData.data.reduce((acc, driver) => {
                acc[driver.driverId] = driver.forename + " " + driver.surname;
                return acc;
            }, {});

            Papa.parse("assets/data/csv/races.csv", {
                header: true,
                download: true,
                complete: function (racesData) {
                    const races = racesData.data.reduce((acc, race) => {
                        acc[race.raceId] = race.year;
                        return acc;
                    }, {});

                    Papa.parse("assets/data/csv/results.csv", {
                        header: true,
                        download: true,
                        complete: function (resultsData) {
                            function getPointsByYear(driverId) {
                                const driverPointsByYear = {};

                                const driverResults = resultsData.data.filter(
                                    (result) => result.driverId === driverId
                                );

                                driverResults.forEach((result) => {
                                    const raceYear = races[result.raceId];
                                    const points = parseInt(result.points);

                                    if (driverPointsByYear[raceYear]) {
                                        driverPointsByYear[raceYear] += points;
                                    } else {
                                        driverPointsByYear[raceYear] = points;
                                    }
                                });

                                return driverPointsByYear;
                            }

                            const width = 800;
                            const height = 300;
                            const margin = { top: 10, right: 10, bottom: 40, left: 60 };
                            const innerWidth = width - margin.left - margin.right;
                            const innerHeight = height - margin.top - margin.bottom;

                            const svg = d3
                                .select("#points_chart")
                                .append("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                .attr("transform", `translate(${margin.left}, ${margin.top})`);

                            const xScale = d3.scaleBand().range([0, innerWidth]).padding(0.1);
                            const yScale = d3.scaleLinear().range([innerHeight, 0]);

                            const line = d3
                                .line()
                                .x((d) => xScale(d.year) + xScale.bandwidth() / 2)
                                .y((d) => yScale(d.points));

                            svg
                                .append("g")
                                .attr("class", "x-axis")
                                .attr("transform", `translate(0, ${innerHeight})`);

                            svg.append("g").attr("class", "y-axis");

                            // X-axis label
                            svg.append("text")
                                .attr("class", "axis-label")
                                .attr("x", width / 2)
                                .attr("y", height + margin.top  - 20)
                                .attr("text-anchor", "middle")
                                .text("Year");

                            // Y-axis label
                            svg.append("text")
                                .attr("class", "axis-label")
                                .attr("x", -height / 2 + 15)
                                .attr("y", -margin.left + 15)
                                .attr("text-anchor", "middle")
                                .attr("transform", "rotate(-90)")
                                .text("Points");

                            const tooltip = d3
                                .select("body")
                                .append("div")
                                .attr("class", "tooltip");

                            function initChart() {
                                const driverId1 = "1";
                                const driverId2 = "830";

                                const driver1PointsByYear = getPointsByYear(driverId1);
                                const driver2PointsByYear = getPointsByYear(driverId2);

                                const driver1Data = Object.keys(driver1PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver1PointsByYear[year],
                                    driver: 1,
                                }));

                                const driver2Data = Object.keys(driver2PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver2PointsByYear[year],
                                    driver: 2,
                                }));

                                const data = driver1Data.concat(driver2Data);

                                // Sort the data by year in ascending order
                                data.sort((a, b) => a.year - b.year);

                                xScale.domain(data.map((d) => d.year));
                                yScale.domain([0, d3.max(data, (d) => d.points)]);

                                svg.select(".x-axis").call(d3.axisBottom(xScale));
                                svg.select(".y-axis").call(d3.axisLeft(yScale));

                                svg.selectAll(".line").remove();

                                // Add the line for driver 1 with line drawing animation
                                svg.append("path")
                                    .datum(driver1Data)
                                    .attr("class", "line line1")
                                    .attr("fill", "none")
                                    .attr("stroke", "#377eb8")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .each(function () {
                                        const path = d3.select(this);
                                        const totalLength = path.node().getTotalLength();

                                        path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                            .attr("stroke-dashoffset", totalLength)
                                            .transition()
                                            .duration(2000)
                                            .attr("stroke-dashoffset", 0);
                                    });

                                // Add the line for driver 2 with line drawing animation
                                svg.append("path")
                                    .datum(driver2Data)
                                    .attr("class", "line line2")
                                    .attr("fill", "none")
                                    .attr("stroke", "#e41a1c")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .each(function () {
                                        const path = d3.select(this);
                                        const totalLength = path.node().getTotalLength();

                                        path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                            .attr("stroke-dashoffset", totalLength)
                                            .transition()
                                            .duration(2000)
                                            .attr("stroke-dashoffset", 0);
                                    });

                                svg.selectAll(".dot").remove();

                                // Add the dots for each data point
                                svg
                                    .selectAll(".dot")
                                    .data(data)
                                    .enter()
                                    .append("circle")
                                    .attr("class", "dot")
                                    .attr("cx", (d) => xScale(d.year) + xScale.bandwidth() / 2)
                                    .attr("cy", (d) => yScale(d.points))
                                    .attr("r", 4)
                                    .attr("fill", (d) => (d.driver === 1 ? "#377eb8" : "#e41a1c"))
                                    .on("mouseover", (event, d) => {
                                        tooltip
                                            .style("display", "block")
                                            .style("left", event.pageX + 10 + "px")
                                            .style("top", event.pageY - 10 + "px")
                                            .html(`Year: ${d.year}<br/>Points: ${d.points}`);
                                    })
                                    .on("mouseout", () => {
                                        tooltip.style("display", "none");
                                    });
                            }

                            // Function to update the chart based on selected drivers
                            function updateChart() {
                                const driverId1 = driverSelect1.value;
                                const driverId2 = driverSelect2.value;

                                const driver1PointsByYear = getPointsByYear(driverId1);
                                const driver2PointsByYear = getPointsByYear(driverId2);

                                const driver1Data = Object.keys(driver1PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver1PointsByYear[year],
                                    driver: 1,
                                }));

                                const driver2Data = Object.keys(driver2PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver2PointsByYear[year],
                                    driver: 2,
                                }));

                                const data = driver1Data.concat(driver2Data);

                                // Sort the data by year in ascending order
                                data.sort((a, b) => a.year - b.year);

                                xScale.domain(data.map((d) => d.year));
                                yScale.domain([0, d3.max(data, (d) => d.points)]);

                                svg.select(".x-axis").call(d3.axisBottom(xScale));
                                svg.select(".y-axis").call(d3.axisLeft(yScale));

                                svg.selectAll(".line").remove();

                                // Add the line for driver 1 with line drawing animation
                                svg.append("path")
                                    .datum(driver1Data)
                                    .attr("class", "line line1")
                                    .attr("fill", "none")
                                    .attr("stroke", "#377eb8")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .each(function () {
                                        const path = d3.select(this);
                                        const totalLength = path.node().getTotalLength();

                                        path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                            .attr("stroke-dashoffset", totalLength)
                                            .transition()
                                            .duration(2000)
                                            .attr("stroke-dashoffset", 0);
                                    });

                                // Add the line for driver 2 with line drawing animation
                                svg.append("path")
                                    .datum(driver2Data)
                                    .attr("class", "line line2")
                                    .attr("fill", "none")
                                    .attr("stroke", "#e41a1c")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .each(function () {
                                        const path = d3.select(this);
                                        const totalLength = path.node().getTotalLength();

                                        path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                            .attr("stroke-dashoffset", totalLength)
                                            .transition()
                                            .duration(2000)
                                            .attr("stroke-dashoffset", 0);
                                    });

                                svg.selectAll(".dot").remove();

                                svg
                                    .selectAll(".dot")
                                    .data(data)
                                    .enter()
                                    .append("circle")
                                    .attr("class", "dot")
                                    .attr("cx", (d) => xScale(d.year) + xScale.bandwidth() / 2)
                                    .attr("cy", (d) => yScale(d.points))
                                    .attr("r", 4)
                                    .attr("fill", (d) => (d.driver === 1 ? "#377eb8" : "#e41a1c"))
                                    .on("mouseover", (event, d) => {
                                        tooltip
                                            .style("display", "block")
                                            .style("left", event.pageX + 10 + "px")
                                            .style("top", event.pageY - 10 + "px")
                                            .html(`Year: ${d.year}<br/>Points: ${d.points}`);
                                    })
                                    .on("mouseout", () => {
                                        tooltip.style("display", "none");
                                    });
                            }

                            setTimeout(function() {
                                // Initialize the chart with preset drivers
                                initChart();
                            }, 2000);

                            // Listen for change in driver selection
                            const driverSelect1 = document.getElementById("driverSelect1");
                            const driverSelect2 = document.getElementById("driverSelect2");

                            driverSelect1.addEventListener("change", updateChart);
                            driverSelect2.addEventListener("change", updateChart);

                        },
                    });
                },
            });
        },
    });
</script>

<!-- Most Fastest Laps by Season -->
<script>

    Papa.parse("assets/data/csv/drivers.csv", {
        header: true,
        download: true,
        complete: function (driversData) {
            const drivers = driversData.data.reduce((acc, driver) => {
                acc[driver.driverId] = driver.forename + " " + driver.surname;
                return acc;
            }, {});

            Papa.parse("assets/data/csv/races.csv", {
                header: true,
                download: true,
                complete: function (racesData) {

                    const races = racesData.data.reduce((acc, race) => {
                        acc[race.raceId] = race.year;
                        return acc;
                    }, {});

                    Papa.parse("assets/data/csv/results.csv", {
                        header: true,
                        download: true,
                        complete: function (resultsData) {
                            // Function to count rank 1 (fastest lap) finishes by year for a driver
                            function countRank1ByYear(driverId) {
                                const rank1CountByYear = {};

                                // Filter results based on driver ID and rank 1
                                const driverResults = resultsData.data.filter(
                                    (result) => result.driverId === driverId && result.rank === "1"
                                );

                                // Count rank 1 finishes by year
                                driverResults.forEach((result) => {
                                    const raceYear = races[result.raceId];

                                    if (rank1CountByYear[raceYear]) {
                                        rank1CountByYear[raceYear] += 1;
                                    } else {
                                        rank1CountByYear[raceYear] = 1;
                                    }
                                });

                                return rank1CountByYear;
                            }

                            const width = 800;
                            const height = 300;
                            const margin = { top: 10, right: 10, bottom: 40, left: 90 };
                            const innerWidth = width - margin.left - margin.right;
                            const innerHeight = height - margin.top - margin.bottom;

                            const svg = d3
                                .select("#laps_chart")
                                .append("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                .attr("transform", `translate(${margin.left}, ${margin.top})`);

                            const xScale = d3.scaleBand().range([0, innerWidth]).padding(0.1);
                            const yScale = d3.scaleLinear().range([innerHeight, 0]);

                            const line = d3
                                .line()
                                .x((d) => xScale(d.year) + xScale.bandwidth() / 2)
                                .y((d) => yScale(d.points));

                            svg
                                .append("g")
                                .attr("class", "x-axis")
                                .attr("transform", `translate(0, ${innerHeight})`);

                            svg.append("g").attr("class", "y-axis");

                            svg.append("text")
                                .attr("class", "axis-label")
                                .attr("x", width / 2)
                                .attr("y", height + margin.top - 20)
                                .attr("text-anchor", "middle")
                                .text("Year");

                            svg.append("text")
                                .attr("class", "axis-label")
                                .attr("x", -height / 2 + 15)
                                .attr("y", -margin.left + 50)
                                .attr("text-anchor", "middle")
                                .attr("transform", "rotate(-90)")
                                .text("Fastest Lap");

                            const tooltip = d3
                                .select("body")
                                .append("div")
                                .attr("class", "tooltip");

                            function initChart2() {
                                const driverId1 = "1";
                                const driverId2 = "830";

                                const driver1PointsByYear = countRank1ByYear(driverId1);
                                const driver2PointsByYear = countRank1ByYear(driverId2);

                                const driver1Data = Object.keys(driver1PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver1PointsByYear[year],
                                    driver: 1,
                                }));

                                const driver2Data = Object.keys(driver2PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver2PointsByYear[year],
                                    driver: 2,
                                }));

                                const data = driver1Data.concat(driver2Data);

                                // Sort the data by year in ascending order
                                data.sort((a, b) => a.year - b.year);

                                xScale.domain(data.map((d) => d.year));
                                yScale.domain([0, d3.max(data, (d) => d.points)]);


                                svg.select(".x-axis").call(d3.axisBottom(xScale));
                                svg.select(".y-axis").call(d3.axisLeft(yScale));

                                svg.selectAll(".line").remove();

                                // Add the line for driver 1 with line drawing animation
                                svg.append("path")
                                    .datum(driver1Data)
                                    .attr("class", "line line1")
                                    .attr("fill", "none")
                                    .attr("stroke", "#377eb8")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .call(animateLine);

                                // Add the line for driver 2 with line drawing animation
                                svg.append("path")
                                    .datum(driver2Data)
                                    .attr("class", "line line2")
                                    .attr("fill", "none")
                                    .attr("stroke", "#e41a1c")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .call(animateLine);

                                // Function to animate the line drawing
                                function animateLine(path) {
                                    const totalLength = path.node().getTotalLength();

                                    path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                        .attr("stroke-dashoffset", totalLength)
                                        .transition()
                                        .duration(2000)
                                        .ease(d3.easeLinear)
                                        .attr("stroke-dashoffset", 0);
                                }

                                svg.selectAll(".dot").remove();

                                // Add the dots for each data point
                                svg
                                    .selectAll(".dot")
                                    .data(data)
                                    .enter()
                                    .append("circle")
                                    .attr("class", "dot")
                                    .attr("cx", (d) => xScale(d.year) + xScale.bandwidth() / 2)
                                    .attr("cy", (d) => yScale(d.points))
                                    .attr("r", 4)
                                    .attr("fill", (d) => (d.driver === 1 ? "#377eb8" : "#e41a1c"))
                                    .on("mouseover", (event, d) => {
                                        tooltip
                                            .style("display", "block")
                                            .style("left", event.pageX + 10 + "px")
                                            .style("top", event.pageY - 10 + "px")
                                            .html(`Year: ${d.year}<br/>Fastest Lap: ${d.points}`);
                                    })
                                    .on("mouseout", () => {
                                        tooltip.style("display", "none");
                                    });
                            }

                            // Function to update the chart based on selected drivers
                            function updateChart2() {
                                const driverId1 = driverSelect1.value;
                                const driverId2 = driverSelect2.value;

                                const driver1PointsByYear = countRank1ByYear(driverId1);
                                const driver2PointsByYear = countRank1ByYear(driverId2);

                                const driver1Data = Object.keys(driver1PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver1PointsByYear[year],
                                    driver: 1,
                                }));

                                const driver2Data = Object.keys(driver2PointsByYear).map((year) => ({
                                    year: year,
                                    points: driver2PointsByYear[year],
                                    driver: 2,
                                }));

                                const data = driver1Data.concat(driver2Data);

                                // Sort the data by year in ascending order
                                data.sort((a, b) => a.year - b.year);

                                xScale.domain(data.map((d) => d.year));
                                yScale.domain([0, d3.max(data, (d) => d.points)]);

                                svg.select(".x-axis").call(d3.axisBottom(xScale));
                                svg.select(".y-axis").call(d3.axisLeft(yScale));

                                svg.selectAll(".line").remove();

                                // Add the line for driver 1 with line drawing animation
                                svg.append("path")
                                    .datum(driver1Data)
                                    .attr("class", "line line1")
                                    .attr("fill", "none")
                                    .attr("stroke", "#377eb8")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .call(animateLine);

                                // Add the line for driver 2 with line drawing animation
                                svg.append("path")
                                    .datum(driver2Data)
                                    .attr("class", "line line2")
                                    .attr("fill", "none")
                                    .attr("stroke", "#e41a1c")
                                    .attr("stroke-width", 2)
                                    .attr("d", line)
                                    .call(animateLine);

                                // Function to animate the line drawing
                                function animateLine(path) {
                                    const totalLength = path.node().getTotalLength();

                                    path.attr("stroke-dasharray", totalLength + " " + totalLength)
                                        .attr("stroke-dashoffset", totalLength)
                                        .transition()
                                        .duration(2000)
                                        .ease(d3.easeLinear)
                                        .attr("stroke-dashoffset", 0);
                                }

                                svg.selectAll(".dot").remove();

                                // Add the dots for each data point
                                svg
                                    .selectAll(".dot")
                                    .data(data)
                                    .enter()
                                    .append("circle")
                                    .attr("class", "dot")
                                    .attr("cx", (d) => xScale(d.year) + xScale.bandwidth() / 2)
                                    .attr("cy", (d) => yScale(d.points))
                                    .attr("r", 4)
                                    .attr("fill", (d) => (d.driver === 1 ? "#377eb8" : "#e41a1c"))
                                    .on("mouseover", (event, d) => {
                                        tooltip
                                            .style("display", "block")
                                            .style("left", event.pageX + 10 + "px")
                                            .style("top", event.pageY - 10 + "px")
                                            .html(`Year: ${d.year}<br/>Fastest Lap: ${d.points}`);
                                    })
                                    .on("mouseout", () => {
                                        tooltip.style("display", "none");
                                    });
                            }

                            setTimeout(function() {
                                // Initialize the chart with preset drivers
                                initChart2();
                            }, 2000);

                            // Listen for change in driver selection
                            const driverSelect1 = document.getElementById("driverSelect1");
                            const driverSelect2 = document.getElementById("driverSelect2");

                            driverSelect1.addEventListener("change", updateChart2);
                            driverSelect2.addEventListener("change", updateChart2);

                        },
                    });
                },
            });
        },
    });
</script>

<!-- End -->

</body>

</html>